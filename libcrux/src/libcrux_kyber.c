/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>
  KaRaMeL invocation: /Users/franziskus/repos/eurydice//eurydice --config
  ../../kyber-c.yaml ../libcrux_kyber.llbc F* version: a32b316e KaRaMeL version:
  a1e1b1f2
 */

#include "internal/libcrux_kyber.h"

#include "internal/core.h"
#include "libcrux_hacl_glue.h"

#define FIELD_MODULUS ((int32_t)3329)

#define BITS_PER_COEFFICIENT ((size_t)12U)

#define COEFFICIENTS_IN_RING_ELEMENT ((size_t)256U)

#define BITS_PER_RING_ELEMENT (COEFFICIENTS_IN_RING_ELEMENT * (size_t)12U)

#define BYTES_PER_RING_ELEMENT (BITS_PER_RING_ELEMENT / (size_t)8U)

#define SHARED_SECRET_SIZE ((size_t)32U)

#define CPA_PKE_KEY_GENERATION_SEED_SIZE ((size_t)32U)

#define H_DIGEST_SIZE ((size_t)32U)

#define MONTGOMERY_SHIFT (16U)

static uint32_t
get_n_least_significant_bits(uint8_t n, uint32_t value)
{
  return value & ((1U << (uint32_t)n) - 1U);
}

#define BARRETT_SHIFT ((int64_t)26)

#define BARRETT_R ((int64_t)1 << (uint32_t)BARRETT_SHIFT)

#define BARRETT_MULTIPLIER ((int64_t)20159)

static int32_t
barrett_reduce(int32_t value)
{
  int64_t t = core_convert_num__i64_59__from(value) * BARRETT_MULTIPLIER +
              (BARRETT_R >> 1U);
  int32_t quotient = (int32_t)(t >> (uint32_t)BARRETT_SHIFT);
  return value - quotient * FIELD_MODULUS;
}

#define INVERSE_OF_MODULUS_MOD_MONTGOMERY_R (62209U)

static int32_t
montgomery_reduce(int32_t value)
{
  uint32_t t = get_n_least_significant_bits(MONTGOMERY_SHIFT, (uint32_t)value) *
               INVERSE_OF_MODULUS_MOD_MONTGOMERY_R;
  int16_t k = (int16_t)get_n_least_significant_bits(MONTGOMERY_SHIFT, t);
  int32_t k_times_modulus = (int32_t)k * FIELD_MODULUS;
  int32_t c = k_times_modulus >> (uint32_t)MONTGOMERY_SHIFT;
  int32_t value_high = value >> (uint32_t)MONTGOMERY_SHIFT;
  return value_high - c;
}

static int32_t
montgomery_multiply_fe_by_fer(int32_t fe, int32_t fer)
{
  return montgomery_reduce(fe * fer);
}

#define MONTGOMERY_R_SQUARED_MOD_FIELD_MODULUS ((int32_t)1353)

static int32_t
to_standard_domain(int32_t mfe)
{
  return montgomery_reduce(mfe * MONTGOMERY_R_SQUARED_MOD_FIELD_MODULUS);
}

static uint16_t
to_unsigned_representative(int32_t fe)
{
  return (uint16_t)(fe + (FIELD_MODULUS & fe >> 31U));
}

typedef int32_t PolynomialRingElement[256U];

static const int32_t ZERO[256U] = { 0U };

static uint8_t
compress_message_coefficient(uint16_t fe)
{
  int16_t shifted = (int16_t)1664 - (int16_t)fe;
  int16_t mask = shifted >> 15U;
  int16_t shifted_to_positive = mask ^ shifted;
  int16_t shifted_positive_in_range = shifted_to_positive - (int16_t)832;
  return (uint8_t)(shifted_positive_in_range >> 15U & (int16_t)1);
}

static int32_t
compress_ciphertext_coefficient(uint8_t coefficient_bits, uint16_t fe)
{
  uint64_t compressed = (uint64_t)fe << (uint32_t)coefficient_bits;
  compressed = compressed + 1664ULL;
  compressed = compressed * 10321340ULL;
  compressed = compressed >> 35U;
  return (int32_t)get_n_least_significant_bits(coefficient_bits,
                                               (uint32_t)compressed);
}

static int32_t
decompress_message_coefficient(int32_t fe)
{
  return -fe & (FIELD_MODULUS + (int32_t)1) / (int32_t)2;
}

static int32_t
decompress_ciphertext_coefficient(uint8_t coefficient_bits, int32_t fe)
{
  uint32_t decompressed = (uint32_t)fe * (uint32_t)FIELD_MODULUS;
  decompressed = (decompressed << 1U) + (1U << (uint32_t)coefficient_bits);
  decompressed = decompressed >> (uint32_t)((uint32_t)coefficient_bits + 1U);
  return (int32_t)decompressed;
}

static uint8_t
is_non_zero(uint8_t value)
{
  uint16_t value0 = (uint16_t)value;
  uint16_t uu____0 = value0;
  uint16_t
  result =
    (((uint32_t)uu____0 | (uint32_t)core_num__u16_7__wrapping_add(~value0, 1U)) & 0xFFFFU)
    >> 8U
    & 1U;
  return (uint8_t)result;
}

static void
select_shared_secret_in_constant_time(Eurydice_slice lhs,
                                      Eurydice_slice rhs,
                                      uint8_t selector,
                                      uint8_t ret[32U])
{
  uint8_t mask = core_num__u8_6__wrapping_sub(is_non_zero(selector), 1U);
  uint8_t out[32U] = { 0U };
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){ .start = (size_t)0U,
                                     .end = SHARED_SECRET_SIZE }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      uint8_t uu____1 =
        (uint32_t)Eurydice_slice_index(lhs, i, uint8_t, uint8_t) &
        (uint32_t)mask;
      uint8_t* uu____2 = &Eurydice_slice_index(rhs, i, uint8_t, uint8_t);
      out[i] = (uint32_t)uu____1 | ((uint32_t)uu____2[0U] & (uint32_t)~mask);
    }
  }
  uint8_t uu____3[32U];
  memcpy(uu____3, out, (size_t)32U * sizeof(uint8_t));
  memcpy(ret, uu____3, (size_t)32U * sizeof(uint8_t));
}

static void
G(Eurydice_slice input, uint8_t ret[64U])
{
  uint8_t ret0[64U];
  libcrux_digest_sha3_512(input, ret0);
  memcpy(ret, ret0, (size_t)64U * sizeof (uint8_t));
}

static void
H(Eurydice_slice input, uint8_t ret[32U])
{
  uint8_t ret0[32U];
  libcrux_digest_sha3_256(input, ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

static void
free_state(libcrux_digest_incremental_x4_Shake128StateX4 xof_state)
{
  libcrux_digest_incremental_x4__libcrux__digest__incremental_x4__Shake128StateX4__free_memory(
    xof_state);
}

typedef struct __uint8_t_uint8_t_uint8_t_s
{
  uint8_t fst;
  uint8_t snd;
  uint8_t thd;
} __uint8_t_uint8_t_uint8_t;

static __uint8_t_uint8_t_uint8_t
compress_coefficients_3(uint16_t coefficient1, uint16_t coefficient2)
{
  uint8_t coef1 = (uint8_t)((uint32_t)coefficient1 & 255U);
  uint8_t coef2 = (uint8_t)((uint32_t)coefficient1 >> 8U | ((uint32_t)coefficient2 & 15U) << 4U);
  uint8_t coef3 = (uint8_t)((uint32_t)coefficient2 >> 4U & 255U);
  return (
    (__uint8_t_uint8_t_uint8_t){ .fst = coef1, .snd = coef2, .thd = coef3 });
}

static void
serialize_uncompressed_ring_element(int32_t re[256U], uint8_t ret[384U])
{
  uint8_t serialized[384U] = { 0U };
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t, Eurydice_slice),
      int32_t,
      size_t) /
    (size_t)2U;
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    lit, core_ops_range_Range__size_t, core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      Eurydice_slice coefficients = Eurydice_array_to_subslice(
        (size_t)256U,
        re,
        ((core_ops_range_Range__size_t){ .start = i * (size_t)2U,
                                         .end = i * (size_t)2U + (size_t)2U }),
        int32_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
      uint16_t coefficient1 = to_unsigned_representative(
        Eurydice_slice_index(coefficients, (size_t)0U, int32_t, int32_t));
      uint16_t coefficient2 = to_unsigned_representative(
        Eurydice_slice_index(coefficients, (size_t)1U, int32_t, int32_t));
      __uint8_t_uint8_t_uint8_t uu____1 =
        compress_coefficients_3(coefficient1, coefficient2);
      uint8_t coef1 = uu____1.fst;
      uint8_t coef2 = uu____1.snd;
      uint8_t coef3 = uu____1.thd;
      serialized[(size_t)3U * i] = coef1;
      serialized[(size_t)3U * i + (size_t)1U] = coef2;
      serialized[(size_t)3U * i + (size_t)2U] = coef3;
    }
  }
  uint8_t uu____2[384U];
  memcpy(uu____2, serialized, (size_t)384U * sizeof (uint8_t));
  memcpy(ret, uu____2, (size_t)384U * sizeof (uint8_t));
}

static void
deserialize_to_uncompressed_ring_element(Eurydice_slice serialized,
                                         int32_t ret[256U])
{
  int32_t re[256U];
  memcpy(re, ZERO, (size_t)256U * sizeof(int32_t));
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){
      .start = (size_t)0U,
      .end =
        core_slice___Slice_T___len(serialized, uint8_t, size_t) / (size_t)3U }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      Eurydice_slice
      bytes =
        Eurydice_slice_subslice(serialized,
          (
            (core_ops_range_Range__size_t){
              .start = i * (size_t)3U,
              .end = i * (size_t)3U + (size_t)3U
            }
          ),
          uint8_t,
          core_ops_range_Range__size_t,
          Eurydice_slice);
      int32_t byte1 = (int32_t)Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
      int32_t byte2 = (int32_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
      int32_t byte3 = (int32_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
      re[(size_t)2U * i] = (byte2 & (int32_t)15) << 8U | (byte1 & (int32_t)255);
      re[(size_t)2U * i + (size_t)1U] = byte3 << 4U | (byte2 >> 4U & (int32_t)15);
    }
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

static void
sample_from_binomial_distribution_2(Eurydice_slice randomness,
                                    int32_t ret[256U])
{
  int32_t sampled[256U];
  memcpy(sampled, ZERO, (size_t)256U * sizeof(int32_t));
  core_ops_range_Range__size_t iter0 = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){
      .start = (size_t)0U,
      .end =
        core_slice___Slice_T___len(randomness, uint8_t, size_t) / (size_t)4U }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter0, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t chunk_number = uu____0.f0;
      Eurydice_slice
      byte_chunk =
        Eurydice_slice_subslice(randomness,
          (
            (core_ops_range_Range__size_t){
              .start = chunk_number * (size_t)4U,
              .end = chunk_number * (size_t)4U + (size_t)4U
            }
          ),
          uint8_t,
          core_ops_range_Range__size_t,
          Eurydice_slice);
      uint32_t uu____1 = (uint32_t)Eurydice_slice_index(byte_chunk, (size_t)0U, uint8_t, uint8_t);
      uint32_t
      uu____2 =
        uu____1
        | (uint32_t)Eurydice_slice_index(byte_chunk, (size_t)1U, uint8_t, uint8_t) << 8U;
      uint32_t
      uu____3 =
        uu____2
        | (uint32_t)Eurydice_slice_index(byte_chunk, (size_t)2U, uint8_t, uint8_t) << 16U;
      uint32_t
      random_bits_as_u32 =
        uu____3
        | (uint32_t)Eurydice_slice_index(byte_chunk, (size_t)3U, uint8_t, uint8_t) << 24U;
      uint32_t even_bits = random_bits_as_u32 & 1431655765U;
      uint32_t odd_bits = random_bits_as_u32 >> 1U & 1431655765U;
      uint32_t coin_toss_outcomes = even_bits + odd_bits;
      core_ops_range_Range__uint32_t iter =
        core_iter_traits_collect__I__into_iter(
          ((core_ops_range_Range__uint32_t){
            .start = 0U, .end = CORE_NUM__U32_8__BITS / 4U }),
          core_ops_range_Range__uint32_t,
          core_ops_range_Range__uint32_t);
      while (true) {
        core_option_Option__uint32_t uu____4 =
          core_iter_range__core__ops__range__Range_A__3__next(
            &iter, uint32_t, core_option_Option__uint32_t);
        if (uu____4.tag == core_option_None) {
          break;
        } else {
          uint32_t outcome_set = uu____4.f0;
          uint32_t outcome_set0 = outcome_set * 4U;
          int32_t outcome_1 = (int32_t)(coin_toss_outcomes >> (uint32_t)outcome_set0 & 3U);
          int32_t outcome_2 = (int32_t)(coin_toss_outcomes >> (uint32_t)(outcome_set0 + 2U) & 3U);
          size_t offset = (size_t)(outcome_set0 >> 2U);
          sampled[(size_t)8U * chunk_number + offset] = outcome_1 - outcome_2;
        }
      }
    }
  }
  memcpy(ret, sampled, (size_t)256U * sizeof (int32_t));
}

static void
sample_from_binomial_distribution_3(Eurydice_slice randomness,
                                    int32_t ret[256U])
{
  int32_t sampled[256U];
  memcpy(sampled, ZERO, (size_t)256U * sizeof(int32_t));
  core_ops_range_Range__size_t iter0 = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){
      .start = (size_t)0U,
      .end =
        core_slice___Slice_T___len(randomness, uint8_t, size_t) / (size_t)3U }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter0, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t chunk_number = uu____0.f0;
      Eurydice_slice
      byte_chunk =
        Eurydice_slice_subslice(randomness,
          (
            (core_ops_range_Range__size_t){
              .start = chunk_number * (size_t)3U,
              .end = chunk_number * (size_t)3U + (size_t)3U
            }
          ),
          uint8_t,
          core_ops_range_Range__size_t,
          Eurydice_slice);
      uint32_t uu____1 = (uint32_t)Eurydice_slice_index(byte_chunk, (size_t)0U, uint8_t, uint8_t);
      uint32_t
      uu____2 =
        uu____1
        | (uint32_t)Eurydice_slice_index(byte_chunk, (size_t)1U, uint8_t, uint8_t) << 8U;
      uint32_t
      random_bits_as_u24 =
        uu____2
        | (uint32_t)Eurydice_slice_index(byte_chunk, (size_t)2U, uint8_t, uint8_t) << 16U;
      uint32_t first_bits = random_bits_as_u24 & 2396745U;
      uint32_t second_bits = random_bits_as_u24 >> 1U & 2396745U;
      uint32_t third_bits = random_bits_as_u24 >> 2U & 2396745U;
      uint32_t coin_toss_outcomes = first_bits + second_bits + third_bits;
      core_ops_range_Range__int32_t iter =
        core_iter_traits_collect__I__into_iter(
          ((core_ops_range_Range__int32_t){ .start = (int32_t)0,
                                            .end = (int32_t)24 / (int32_t)6 }),
          core_ops_range_Range__int32_t,
          core_ops_range_Range__int32_t);
      while (true) {
        core_option_Option__int32_t uu____3 =
          core_iter_range__core__ops__range__Range_A__3__next(
            &iter, int32_t, core_option_Option__int32_t);
        if (uu____3.tag == core_option_None) {
          break;
        } else {
          int32_t outcome_set = uu____3.f0;
          int32_t outcome_set0 = outcome_set * (int32_t)6;
          int32_t outcome_1 = (int32_t)(coin_toss_outcomes >> (uint32_t)outcome_set0 & 7U);
          int32_t
          outcome_2 = (int32_t)(coin_toss_outcomes >> (uint32_t)(outcome_set0 + (int32_t)3) & 7U);
          size_t offset = (size_t)(outcome_set0 / (int32_t)6);
          sampled[(size_t)4U * chunk_number + offset] = outcome_1 - outcome_2;
        }
      }
    }
  }
  memcpy(ret, sampled, (size_t)256U * sizeof (int32_t));
}

static const int32_t ZETAS_TIMES_MONTGOMERY_R[128U] = {
  (int32_t)-1044, (int32_t)-758,  (int32_t)-359,  (int32_t)-1517,
  (int32_t)1493,  (int32_t)1422,  (int32_t)287,   (int32_t)202,
  (int32_t)-171,  (int32_t)622,   (int32_t)1577,  (int32_t)182,
  (int32_t)962,   (int32_t)-1202, (int32_t)-1474, (int32_t)1468,
  (int32_t)573,   (int32_t)-1325, (int32_t)264,   (int32_t)383,
  (int32_t)-829,  (int32_t)1458,  (int32_t)-1602, (int32_t)-130,
  (int32_t)-681,  (int32_t)1017,  (int32_t)732,   (int32_t)608,
  (int32_t)-1542, (int32_t)411,   (int32_t)-205,  (int32_t)-1571,
  (int32_t)1223,  (int32_t)652,   (int32_t)-552,  (int32_t)1015,
  (int32_t)-1293, (int32_t)1491,  (int32_t)-282,  (int32_t)-1544,
  (int32_t)516,   (int32_t)-8,    (int32_t)-320,  (int32_t)-666,
  (int32_t)-1618, (int32_t)-1162, (int32_t)126,   (int32_t)1469,
  (int32_t)-853,  (int32_t)-90,   (int32_t)-271,  (int32_t)830,
  (int32_t)107,   (int32_t)-1421, (int32_t)-247,  (int32_t)-951,
  (int32_t)-398,  (int32_t)961,   (int32_t)-1508, (int32_t)-725,
  (int32_t)448,   (int32_t)-1065, (int32_t)677,   (int32_t)-1275,
  (int32_t)-1103, (int32_t)430,   (int32_t)555,   (int32_t)843,
  (int32_t)-1251, (int32_t)871,   (int32_t)1550,  (int32_t)105,
  (int32_t)422,   (int32_t)587,   (int32_t)177,   (int32_t)-235,
  (int32_t)-291,  (int32_t)-460,  (int32_t)1574,  (int32_t)1653,
  (int32_t)-246,  (int32_t)778,   (int32_t)1159,  (int32_t)-147,
  (int32_t)-777,  (int32_t)1483,  (int32_t)-602,  (int32_t)1119,
  (int32_t)-1590, (int32_t)644,   (int32_t)-872,  (int32_t)349,
  (int32_t)418,   (int32_t)329,   (int32_t)-156,  (int32_t)-75,
  (int32_t)817,   (int32_t)1097,  (int32_t)603,   (int32_t)610,
  (int32_t)1322,  (int32_t)-1285, (int32_t)-1465, (int32_t)384,
  (int32_t)-1215, (int32_t)-136,  (int32_t)1218,  (int32_t)-1335,
  (int32_t)-874,  (int32_t)220,   (int32_t)-1187, (int32_t)-1659,
  (int32_t)-1185, (int32_t)-1530, (int32_t)-1278, (int32_t)794,
  (int32_t)-1510, (int32_t)-854,  (int32_t)-870,  (int32_t)478,
  (int32_t)-108,  (int32_t)-308,  (int32_t)996,   (int32_t)991,
  (int32_t)958,   (int32_t)-1460, (int32_t)1522,  (int32_t)1628
};

static void
ntt_at_layer(size_t* zeta_i, int32_t re[256U], size_t layer, int32_t ret[256U])
{
  size_t step = (size_t)1U << (uint32_t)layer;
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){ .start = (size_t)0U,
                                     .end = (size_t)128U >> (uint32_t)layer }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t round = uu____0.f0;
      zeta_i[0U] = zeta_i[0U] + (size_t)1U;
      size_t offset = round * step * (size_t)2U;
      core_ops_range_Range__size_t
      iter0 =
        core_iter_traits_collect__I__into_iter((
            (core_ops_range_Range__size_t){ .start = offset, .end = offset + step }
          ),
          core_ops_range_Range__size_t,
          core_ops_range_Range__size_t);
      while (true) {
        core_option_Option__size_t uu____1 =
          core_iter_range__core__ops__range__Range_A__3__next(
            &iter0, size_t, core_option_Option__size_t);
        if (uu____1.tag == core_option_None) {
          break;
        } else {
          size_t j = uu____1.f0;
          int32_t t = montgomery_multiply_fe_by_fer(
            re[j + step], ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
          re[j + step] = re[j] - t;
          re[j] = re[j] + t;
        }
      }
    }
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

static void
ntt_at_layer_3(size_t* zeta_i,
               int32_t re[256U],
               size_t layer,
               int32_t ret[256U])
{
  int32_t ret0[256U];
  ntt_at_layer(zeta_i, re, layer, ret0);
  memcpy(ret, ret0, (size_t)256U * sizeof(int32_t));
}

static void
ntt_binomially_sampled_ring_element(int32_t re[256U], int32_t ret[256U])
{
  size_t zeta_i = (size_t)1U;
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){ .start = (size_t)0U,
                                     .end = (size_t)128U }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t j = uu____0.f0;
      int32_t t = re[j + (size_t)128U] * (int32_t)-1600;
      re[j + (size_t)128U] = re[j] - t;
      re[j] = re[j] + t;
    }
  }
  ntt_at_layer_3(&zeta_i, re, (size_t)6U, re);
  ntt_at_layer_3(&zeta_i, re, (size_t)5U, re);
  ntt_at_layer_3(&zeta_i, re, (size_t)4U, re);
  ntt_at_layer_3(&zeta_i, re, (size_t)3U, re);
  ntt_at_layer_3(&zeta_i, re, (size_t)2U, re);
  ntt_at_layer_3(&zeta_i, re, (size_t)1U, re);
  core_ops_range_Range__size_t iter0 = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){ .start = (size_t)0U,
                                     .end = COEFFICIENTS_IN_RING_ELEMENT }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____1 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter0, size_t, core_option_Option__size_t);
    if (uu____1.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____1.f0;
      int32_t uu____2 = barrett_reduce(re[i]);
      re[i] = uu____2;
    }
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

typedef struct __int32_t_int32_t_s
{
  int32_t fst;
  int32_t snd;
} __int32_t_int32_t;

static __int32_t_int32_t
ntt_multiply_binomials(__int32_t_int32_t _, __int32_t_int32_t _0, int32_t zeta)
{
  int32_t a0 = _.fst;
  int32_t a1 = _.snd;
  int32_t b0 = _0.fst;
  int32_t b1 = _0.snd;
  int32_t uu____0 = a0 * b0;
  int32_t uu____1 =
    montgomery_reduce(uu____0 + montgomery_reduce(a1 * b1) * zeta);
  return ((__int32_t_int32_t){ .fst = uu____1,
                               .snd = montgomery_reduce(a0 * b1 + a1 * b0) });
}

static void
ntt_multiply(int32_t (*lhs)[256U], int32_t (*rhs)[256U], int32_t ret[256U])
{
  int32_t out[256U];
  memcpy(out, ZERO, (size_t)256U * sizeof(int32_t));
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){
      .start = (size_t)0U, .end = COEFFICIENTS_IN_RING_ELEMENT / (size_t)4U }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      __int32_t_int32_t lit0;
      lit0.fst = lhs[0U][(size_t)4U * i];
      lit0.snd = lhs[0U][(size_t)4U * i + (size_t)1U];
      __int32_t_int32_t lit1;
      lit1.fst = rhs[0U][(size_t)4U * i];
      lit1.snd = rhs[0U][(size_t)4U * i + (size_t)1U];
      __int32_t_int32_t product = ntt_multiply_binomials(
        lit0, lit1, ZETAS_TIMES_MONTGOMERY_R[(size_t)64U + i]);
      out[(size_t)4U * i] = product.fst;
      out[(size_t)4U * i + (size_t)1U] = product.snd;
      __int32_t_int32_t lit2;
      lit2.fst = lhs[0U][(size_t)4U * i + (size_t)2U];
      lit2.snd = lhs[0U][(size_t)4U * i + (size_t)3U];
      __int32_t_int32_t lit;
      lit.fst = rhs[0U][(size_t)4U * i + (size_t)2U];
      lit.snd = rhs[0U][(size_t)4U * i + (size_t)3U];
      __int32_t_int32_t product0 = ntt_multiply_binomials(
        lit2, lit, -ZETAS_TIMES_MONTGOMERY_R[(size_t)64U + i]);
      out[(size_t)4U * i + (size_t)2U] = product0.fst;
      out[(size_t)4U * i + (size_t)3U] = product0.snd;
    }
  }
  memcpy(ret, out, (size_t)256U * sizeof (int32_t));
}

typedef struct __uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_s
{
  uint8_t fst;
  uint8_t snd;
  uint8_t thd;
  uint8_t f3;
  uint8_t f4;
} __uint8_t_uint8_t_uint8_t_uint8_t_uint8_t;

static __uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
compress_coefficients_10(int32_t coefficient1,
                         int32_t coefficient2,
                         int32_t coefficient3,
                         int32_t coefficient4)
{
  uint8_t coef1 = (uint8_t)(coefficient1 & (int32_t)255);
  uint8_t
  coef2 =
    (uint32_t)(uint8_t)(coefficient2 & (int32_t)63)
    << 2U
    | (uint32_t)(uint8_t)(coefficient1 >> 8U & (int32_t)3);
  uint8_t
  coef3 =
    (uint32_t)(uint8_t)(coefficient3 & (int32_t)15)
    << 4U
    | (uint32_t)(uint8_t)(coefficient2 >> 6U & (int32_t)15);
  uint8_t
  coef4 =
    (uint32_t)(uint8_t)(coefficient4 & (int32_t)3)
    << 6U
    | (uint32_t)(uint8_t)(coefficient3 >> 4U & (int32_t)63);
  uint8_t coef5 = (uint8_t)(coefficient4 >> 2U & (int32_t)255);
  return ((__uint8_t_uint8_t_uint8_t_uint8_t_uint8_t){
    .fst = coef1, .snd = coef2, .thd = coef3, .f3 = coef4, .f4 = coef5 });
}

typedef struct
  __uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_s
{
  uint8_t fst;
  uint8_t snd;
  uint8_t thd;
  uint8_t f3;
  uint8_t f4;
  uint8_t f5;
  uint8_t f6;
  uint8_t f7;
  uint8_t f8;
  uint8_t f9;
  uint8_t f10;
} __uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t;

static __uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
compress_coefficients_11(int32_t coefficient1,
                         int32_t coefficient2,
                         int32_t coefficient3,
                         int32_t coefficient4,
                         int32_t coefficient5,
                         int32_t coefficient6,
                         int32_t coefficient7,
                         int32_t coefficient8)
{
  uint8_t coef1 = (uint8_t)coefficient1;
  uint8_t
  coef2 =
    (uint32_t)(uint8_t)(coefficient2 & (int32_t)31)
    << 3U
    | (uint32_t)(uint8_t)(coefficient1 >> 8U);
  uint8_t
  coef3 =
    (uint32_t)(uint8_t)(coefficient3 & (int32_t)3)
    << 6U
    | (uint32_t)(uint8_t)(coefficient2 >> 5U);
  uint8_t coef4 = (uint8_t)(coefficient3 >> 2U & (int32_t)255);
  uint8_t
  coef5 =
    (uint32_t)(uint8_t)(coefficient4 & (int32_t)127)
    << 1U
    | (uint32_t)(uint8_t)(coefficient3 >> 10U);
  uint8_t
  coef6 =
    (uint32_t)(uint8_t)(coefficient5 & (int32_t)15)
    << 4U
    | (uint32_t)(uint8_t)(coefficient4 >> 7U);
  uint8_t
  coef7 =
    (uint32_t)(uint8_t)(coefficient6 & (int32_t)1)
    << 7U
    | (uint32_t)(uint8_t)(coefficient5 >> 4U);
  uint8_t coef8 = (uint8_t)(coefficient6 >> 1U & (int32_t)255);
  uint8_t
  coef9 =
    (uint32_t)(uint8_t)(coefficient7 & (int32_t)63)
    << 2U
    | (uint32_t)(uint8_t)(coefficient6 >> 9U);
  uint8_t
  coef10 =
    (uint32_t)(uint8_t)(coefficient8 & (int32_t)7)
    << 5U
    | (uint32_t)(uint8_t)(coefficient7 >> 6U);
  uint8_t coef11 = (uint8_t)(coefficient8 >> 3U);
  return ((
    __uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t){
    .fst = coef1,
    .snd = coef2,
    .thd = coef3,
    .f3 = coef4,
    .f4 = coef5,
    .f5 = coef6,
    .f6 = coef7,
    .f7 = coef8,
    .f8 = coef9,
    .f9 = coef10,
    .f10 = coef11 });
}

static void
invert_ntt_at_layer(size_t* zeta_i,
                    int32_t re[256U],
                    size_t layer,
                    int32_t ret[256U])
{
  size_t step = (size_t)1U << (uint32_t)layer;
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){ .start = (size_t)0U,
                                     .end = (size_t)128U >> (uint32_t)layer }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t round = uu____0.f0;
      zeta_i[0U] = zeta_i[0U] - (size_t)1U;
      size_t offset = round * step * (size_t)2U;
      core_ops_range_Range__size_t
      iter0 =
        core_iter_traits_collect__I__into_iter((
            (core_ops_range_Range__size_t){ .start = offset, .end = offset + step }
          ),
          core_ops_range_Range__size_t,
          core_ops_range_Range__size_t);
      while (true) {
        core_option_Option__size_t uu____1 =
          core_iter_range__core__ops__range__Range_A__3__next(
            &iter0, size_t, core_option_Option__size_t);
        if (uu____1.tag == core_option_None) {
          break;
        } else {
          size_t j = uu____1.f0;
          int32_t a_minus_b = re[j + step] - re[j];
          re[j] = re[j] + re[j + step];
          int32_t uu____2 =
            montgomery_reduce(a_minus_b * ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
          re[j + step] = uu____2;
        }
      }
    }
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

static void
deserialize_then_decompress_message(uint8_t serialized[32U], int32_t ret[256U])
{
  int32_t re[256U];
  memcpy(re, ZERO, (size_t)256U * sizeof(int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(
    Eurydice_array_to_slice((size_t)32U, serialized, uint8_t, Eurydice_slice),
    uint8_t,
    size_t);
  core_ops_range_Range__size_t iter0 = core_iter_traits_collect__I__into_iter(
    lit, core_ops_range_Range__size_t, core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter0, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      uint8_t byte = serialized[i];
      core_ops_range_Range__size_t
      iter =
        core_iter_traits_collect__I__into_iter((
            (core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)8U }
          ),
          core_ops_range_Range__size_t,
          core_ops_range_Range__size_t);
      while (true) {
        core_option_Option__size_t uu____1 =
          core_iter_range__core__ops__range__Range_A__3__next(
            &iter, size_t, core_option_Option__size_t);
        if (uu____1.tag == core_option_None) {
          break;
        } else {
          size_t j = uu____1.f0;
          int32_t coefficient_compressed =
            (int32_t)((uint32_t)byte >> (uint32_t)j & 1U);
          int32_t uu____2 =
            decompress_message_coefficient(coefficient_compressed);
          re[(size_t)8U * i + j] = uu____2;
        }
      }
    }
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

static __uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
compress_coefficients_5(uint8_t coefficient2,
                        uint8_t coefficient1,
                        uint8_t coefficient4,
                        uint8_t coefficient3,
                        uint8_t coefficient5,
                        uint8_t coefficient7,
                        uint8_t coefficient6,
                        uint8_t coefficient8)
{
  uint8_t coef1 = ((uint32_t)coefficient2 & 7U) << 5U | (uint32_t)coefficient1;
  uint8_t
  coef2 =
    (((uint32_t)coefficient4 & 1U) << 7U | (uint32_t)coefficient3 << 2U)
    | (uint32_t)coefficient2 >> 3U;
  uint8_t coef3 = ((uint32_t)coefficient5 & 15U) << 4U | (uint32_t)coefficient4 >> 1U;
  uint8_t
  coef4 =
    (((uint32_t)coefficient7 & 3U) << 6U | (uint32_t)coefficient6 << 1U)
    | (uint32_t)coefficient5 >> 4U;
  uint8_t coef5 = (uint32_t)coefficient8 << 3U | (uint32_t)coefficient7 >> 2U;
  return ((__uint8_t_uint8_t_uint8_t_uint8_t_uint8_t){
    .fst = coef1, .snd = coef2, .thd = coef3, .f3 = coef4, .f4 = coef5 });
}

typedef struct __int32_t_int32_t_int32_t_int32_t_s
{
  int32_t fst;
  int32_t snd;
  int32_t thd;
  int32_t f3;
} __int32_t_int32_t_int32_t_int32_t;

static __int32_t_int32_t_int32_t_int32_t
decompress_coefficients_10(int32_t byte2,
                           int32_t byte1,
                           int32_t byte3,
                           int32_t byte4,
                           int32_t byte5)
{
  int32_t coefficient1 = (byte2 & (int32_t)3) << 8U | (byte1 & (int32_t)255);
  int32_t coefficient2 = (byte3 & (int32_t)15) << 6U | byte2 >> 2U;
  int32_t coefficient3 = (byte4 & (int32_t)63) << 4U | byte3 >> 4U;
  int32_t coefficient4 = byte5 << 2U | byte4 >> 6U;
  return ((__int32_t_int32_t_int32_t_int32_t){ .fst = coefficient1,
                                               .snd = coefficient2,
                                               .thd = coefficient3,
                                               .f3 = coefficient4 });
}

static void
deserialize_then_decompress_10(Eurydice_slice serialized, int32_t ret[256U])
{
  int32_t re[256U];
  memcpy(re, ZERO, (size_t)256U * sizeof(int32_t));
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){
      .start = (size_t)0U,
      .end =
        core_slice___Slice_T___len(serialized, uint8_t, size_t) / (size_t)5U }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      Eurydice_slice bytes = Eurydice_slice_subslice(
        serialized,
        ((core_ops_range_Range__size_t){ .start = i * (size_t)5U,
                                         .end = i * (size_t)5U + (size_t)5U }),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
      int32_t byte1 =
        (int32_t)Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
      int32_t byte2 =
        (int32_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
      int32_t byte3 =
        (int32_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
      int32_t byte4 =
        (int32_t)Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t);
      int32_t byte5 =
        (int32_t)Eurydice_slice_index(bytes, (size_t)4U, uint8_t, uint8_t);
      __int32_t_int32_t_int32_t_int32_t uu____1 =
        decompress_coefficients_10(byte2, byte1, byte3, byte4, byte5);
      int32_t coefficient1 = uu____1.fst;
      int32_t coefficient2 = uu____1.snd;
      int32_t coefficient3 = uu____1.thd;
      int32_t coefficient4 = uu____1.f3;
      int32_t uu____2 = decompress_ciphertext_coefficient(10U, coefficient1);
      re[(size_t)4U * i] = uu____2;
      int32_t uu____3 = decompress_ciphertext_coefficient(10U, coefficient2);
      re[(size_t)4U * i + (size_t)1U] = uu____3;
      int32_t uu____4 = decompress_ciphertext_coefficient(10U, coefficient3);
      re[(size_t)4U * i + (size_t)2U] = uu____4;
      int32_t uu____5 = decompress_ciphertext_coefficient(10U, coefficient4);
      re[(size_t)4U * i + (size_t)3U] = uu____5;
    }
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

typedef struct
  __int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_s
{
  int32_t fst;
  int32_t snd;
  int32_t thd;
  int32_t f3;
  int32_t f4;
  int32_t f5;
  int32_t f6;
  int32_t f7;
} __int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t;

static __int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t
decompress_coefficients_11(int32_t byte2,
                           int32_t byte1,
                           int32_t byte3,
                           int32_t byte5,
                           int32_t byte4,
                           int32_t byte6,
                           int32_t byte7,
                           int32_t byte9,
                           int32_t byte8,
                           int32_t byte10,
                           int32_t byte11)
{
  int32_t coefficient1 = (byte2 & (int32_t)7) << 8U | byte1;
  int32_t coefficient2 = (byte3 & (int32_t)63) << 5U | byte2 >> 3U;
  int32_t coefficient3 = ((byte5 & (int32_t)1) << 10U | byte4 << 2U) | byte3 >> 6U;
  int32_t coefficient4 = (byte6 & (int32_t)15) << 7U | byte5 >> 1U;
  int32_t coefficient5 = (byte7 & (int32_t)127) << 4U | byte6 >> 4U;
  int32_t coefficient6 = ((byte9 & (int32_t)3) << 9U | byte8 << 1U) | byte7 >> 7U;
  int32_t coefficient7 = (byte10 & (int32_t)31) << 6U | byte9 >> 2U;
  int32_t coefficient8 = byte11 << 3U | byte10 >> 5U;
  return ((__int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t){
    .fst = coefficient1,
    .snd = coefficient2,
    .thd = coefficient3,
    .f3 = coefficient4,
    .f4 = coefficient5,
    .f5 = coefficient6,
    .f6 = coefficient7,
    .f7 = coefficient8 });
}

static void
deserialize_then_decompress_11(Eurydice_slice serialized, int32_t ret[256U])
{
  int32_t re[256U];
  memcpy(re, ZERO, (size_t)256U * sizeof(int32_t));
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){
      .start = (size_t)0U,
      .end = core_slice___Slice_T___len(serialized, uint8_t, size_t) /
             (size_t)11U }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      Eurydice_slice bytes = Eurydice_slice_subslice(
        serialized,
        ((core_ops_range_Range__size_t){
          .start = i * (size_t)11U, .end = i * (size_t)11U + (size_t)11U }),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
      int32_t byte1 =
        (int32_t)Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
      int32_t byte2 =
        (int32_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
      int32_t byte3 =
        (int32_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
      int32_t byte4 =
        (int32_t)Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t);
      int32_t byte5 =
        (int32_t)Eurydice_slice_index(bytes, (size_t)4U, uint8_t, uint8_t);
      int32_t byte6 =
        (int32_t)Eurydice_slice_index(bytes, (size_t)5U, uint8_t, uint8_t);
      int32_t byte7 =
        (int32_t)Eurydice_slice_index(bytes, (size_t)6U, uint8_t, uint8_t);
      int32_t byte8 =
        (int32_t)Eurydice_slice_index(bytes, (size_t)7U, uint8_t, uint8_t);
      int32_t byte9 =
        (int32_t)Eurydice_slice_index(bytes, (size_t)8U, uint8_t, uint8_t);
      int32_t byte10 =
        (int32_t)Eurydice_slice_index(bytes, (size_t)9U, uint8_t, uint8_t);
      int32_t byte11 =
        (int32_t)Eurydice_slice_index(bytes, (size_t)10U, uint8_t, uint8_t);
      __int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t
        uu____1 = decompress_coefficients_11(byte2,
                                             byte1,
                                             byte3,
                                             byte5,
                                             byte4,
                                             byte6,
                                             byte7,
                                             byte9,
                                             byte8,
                                             byte10,
                                             byte11);
      int32_t coefficient1 = uu____1.fst;
      int32_t coefficient2 = uu____1.snd;
      int32_t coefficient3 = uu____1.thd;
      int32_t coefficient4 = uu____1.f3;
      int32_t coefficient5 = uu____1.f4;
      int32_t coefficient6 = uu____1.f5;
      int32_t coefficient7 = uu____1.f6;
      int32_t coefficient8 = uu____1.f7;
      int32_t uu____2 = decompress_ciphertext_coefficient(11U, coefficient1);
      re[(size_t)8U * i] = uu____2;
      int32_t uu____3 = decompress_ciphertext_coefficient(11U, coefficient2);
      re[(size_t)8U * i + (size_t)1U] = uu____3;
      int32_t uu____4 = decompress_ciphertext_coefficient(11U, coefficient3);
      re[(size_t)8U * i + (size_t)2U] = uu____4;
      int32_t uu____5 = decompress_ciphertext_coefficient(11U, coefficient4);
      re[(size_t)8U * i + (size_t)3U] = uu____5;
      int32_t uu____6 = decompress_ciphertext_coefficient(11U, coefficient5);
      re[(size_t)8U * i + (size_t)4U] = uu____6;
      int32_t uu____7 = decompress_ciphertext_coefficient(11U, coefficient6);
      re[(size_t)8U * i + (size_t)5U] = uu____7;
      int32_t uu____8 = decompress_ciphertext_coefficient(11U, coefficient7);
      re[(size_t)8U * i + (size_t)6U] = uu____8;
      int32_t uu____9 = decompress_ciphertext_coefficient(11U, coefficient8);
      re[(size_t)8U * i + (size_t)7U] = uu____9;
    }
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

static void
ntt_at_layer_3328(size_t* zeta_i,
                  int32_t re[256U],
                  size_t layer,
                  int32_t ret[256U])
{
  int32_t ret0[256U];
  ntt_at_layer(zeta_i, re, layer, ret0);
  memcpy(ret, ret0, (size_t)256U * sizeof(int32_t));
}

static __int32_t_int32_t
decompress_coefficients_4(uint8_t* byte)
{
  int32_t coefficient1 = (int32_t)Eurydice_bitand_pv_u8(byte, 15U);
  int32_t coefficient2 =
    (int32_t)((uint32_t)Eurydice_shr_pv_u8(byte, (int32_t)4) & 15U);
  return ((__int32_t_int32_t){ .fst = coefficient1, .snd = coefficient2 });
}

static void
deserialize_then_decompress_4(Eurydice_slice serialized, int32_t ret[256U])
{
  int32_t re[256U];
  memcpy(re, ZERO, (size_t)256U * sizeof(int32_t));
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){
      .start = (size_t)0U,
      .end = core_slice___Slice_T___len(serialized, uint8_t, size_t) }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      uint8_t* byte = &Eurydice_slice_index(serialized, i, uint8_t, uint8_t);
      __int32_t_int32_t uu____1 = decompress_coefficients_4(byte);
      int32_t coefficient1 = uu____1.fst;
      int32_t coefficient2 = uu____1.snd;
      int32_t uu____2 = decompress_ciphertext_coefficient(4U, coefficient1);
      re[(size_t)2U * i] = uu____2;
      int32_t uu____3 = decompress_ciphertext_coefficient(4U, coefficient2);
      re[(size_t)2U * i + (size_t)1U] = uu____3;
    }
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

static __int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t
decompress_coefficients_5(int32_t byte1,
                          int32_t byte2,
                          int32_t byte3,
                          int32_t byte4,
                          int32_t byte5)
{
  int32_t coefficient1 = byte1 & (int32_t)31;
  int32_t coefficient2 = (byte2 & (int32_t)3) << 3U | byte1 >> 5U;
  int32_t coefficient3 = byte2 >> 2U & (int32_t)31;
  int32_t coefficient4 = (byte3 & (int32_t)15) << 1U | byte2 >> 7U;
  int32_t coefficient5 = (byte4 & (int32_t)1) << 4U | byte3 >> 4U;
  int32_t coefficient6 = byte4 >> 1U & (int32_t)31;
  int32_t coefficient7 = (byte5 & (int32_t)7) << 2U | byte4 >> 6U;
  int32_t coefficient8 = byte5 >> 3U;
  return ((__int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t){
    .fst = coefficient1,
    .snd = coefficient2,
    .thd = coefficient3,
    .f3 = coefficient4,
    .f4 = coefficient5,
    .f5 = coefficient6,
    .f6 = coefficient7,
    .f7 = coefficient8 });
}

static void
deserialize_then_decompress_5(Eurydice_slice serialized, int32_t ret[256U])
{
  int32_t re[256U];
  memcpy(re, ZERO, (size_t)256U * sizeof(int32_t));
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){
      .start = (size_t)0U,
      .end =
        core_slice___Slice_T___len(serialized, uint8_t, size_t) / (size_t)5U }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      Eurydice_slice bytes = Eurydice_slice_subslice(
        serialized,
        ((core_ops_range_Range__size_t){ .start = i * (size_t)5U,
                                         .end = i * (size_t)5U + (size_t)5U }),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
      int32_t byte1 =
        (int32_t)Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
      int32_t byte2 =
        (int32_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
      int32_t byte3 =
        (int32_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
      int32_t byte4 =
        (int32_t)Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t);
      int32_t byte5 =
        (int32_t)Eurydice_slice_index(bytes, (size_t)4U, uint8_t, uint8_t);
      __int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t
        uu____1 = decompress_coefficients_5(byte1, byte2, byte3, byte4, byte5);
      int32_t coefficient1 = uu____1.fst;
      int32_t coefficient2 = uu____1.snd;
      int32_t coefficient3 = uu____1.thd;
      int32_t coefficient4 = uu____1.f3;
      int32_t coefficient5 = uu____1.f4;
      int32_t coefficient6 = uu____1.f5;
      int32_t coefficient7 = uu____1.f6;
      int32_t coefficient8 = uu____1.f7;
      int32_t uu____2 = decompress_ciphertext_coefficient(5U, coefficient1);
      re[(size_t)8U * i] = uu____2;
      int32_t uu____3 = decompress_ciphertext_coefficient(5U, coefficient2);
      re[(size_t)8U * i + (size_t)1U] = uu____3;
      int32_t uu____4 = decompress_ciphertext_coefficient(5U, coefficient3);
      re[(size_t)8U * i + (size_t)2U] = uu____4;
      int32_t uu____5 = decompress_ciphertext_coefficient(5U, coefficient4);
      re[(size_t)8U * i + (size_t)3U] = uu____5;
      int32_t uu____6 = decompress_ciphertext_coefficient(5U, coefficient5);
      re[(size_t)8U * i + (size_t)4U] = uu____6;
      int32_t uu____7 = decompress_ciphertext_coefficient(5U, coefficient6);
      re[(size_t)8U * i + (size_t)5U] = uu____7;
      int32_t uu____8 = decompress_ciphertext_coefficient(5U, coefficient7);
      re[(size_t)8U * i + (size_t)6U] = uu____8;
      int32_t uu____9 = decompress_ciphertext_coefficient(5U, coefficient8);
      re[(size_t)8U * i + (size_t)7U] = uu____9;
    }
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

static void
compress_then_serialize_message(int32_t re[256U], uint8_t ret[32U])
{
  uint8_t serialized[32U] = { 0U };
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t, Eurydice_slice),
      int32_t,
      size_t) /
    (size_t)8U;
  core_ops_range_Range__size_t iter0 = core_iter_traits_collect__I__into_iter(
    lit, core_ops_range_Range__size_t, core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter0, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      Eurydice_slice
      coefficients =
        Eurydice_array_to_subslice((size_t)256U,
          re,
          (
            (core_ops_range_Range__size_t){
              .start = i * (size_t)8U,
              .end = i * (size_t)8U + (size_t)8U
            }
          ),
          int32_t,
          core_ops_range_Range__size_t,
          Eurydice_slice);
      core_ops_range_Range__size_t
      iter =
        core_iter_traits_collect__I__into_iter((
            (core_ops_range_Range__size_t){
              .start = (size_t)0U,
              .end = core_slice___Slice_T___len(coefficients, int32_t, size_t)
            }
          ),
          core_ops_range_Range__size_t,
          core_ops_range_Range__size_t);
      while (true) {
        core_option_Option__size_t uu____1 =
          core_iter_range__core__ops__range__Range_A__3__next(
            &iter, size_t, core_option_Option__size_t);
        if (uu____1.tag == core_option_None) {
          break;
        } else {
          size_t j = uu____1.f0;
          int32_t* coefficient =
            &Eurydice_slice_index(coefficients, j, int32_t, int32_t);
          uint16_t coefficient0 = to_unsigned_representative(coefficient[0U]);
          uint8_t coefficient_compressed =
            compress_message_coefficient(coefficient0);
          size_t uu____2 = i;
          serialized[uu____2] =
            (uint32_t)serialized[uu____2]
            | (uint32_t)coefficient_compressed << (uint32_t)j;
        }
      }
    }
  }
  uint8_t uu____3[32U];
  memcpy(uu____3, serialized, (size_t)32U * sizeof (uint8_t));
  memcpy(ret, uu____3, (size_t)32U * sizeof (uint8_t));
}

static void
deserialize_public_key___3size_t(Eurydice_slice public_key,
                                 int32_t ret[3U][256U])
{
  int32_t t_as_ntt[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++) {
    memcpy(t_as_ntt[i], ZERO, (size_t)256U * sizeof(int32_t));
  }
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){
      .start = (size_t)0U,
      .end = core_slice___Slice_T___len(public_key, uint8_t, size_t) /
             BYTES_PER_RING_ELEMENT }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      Eurydice_slice t_as_ntt_bytes = Eurydice_slice_subslice(
        public_key,
        ((core_ops_range_Range__size_t){ .start = i * BYTES_PER_RING_ELEMENT,
                                         .end = i * BYTES_PER_RING_ELEMENT +
                                                BYTES_PER_RING_ELEMENT }),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
      int32_t uu____1[256U];
      deserialize_to_uncompressed_ring_element(t_as_ntt_bytes, uu____1);
      memcpy(t_as_ntt[i], uu____1, (size_t)256U * sizeof(int32_t));
    }
  }
  int32_t uu____2[3U][256U];
  memcpy(uu____2, t_as_ntt, (size_t)3U * sizeof(int32_t[256U]));
  memcpy(ret, uu____2, (size_t)3U * sizeof(int32_t[256U]));
}

static void
serialize_secret_key___3size_t_1152size_t(int32_t key[3U][256U],
                                          uint8_t ret[1152U])
{
  uint8_t out[1152U] = { 0U };
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(
    Eurydice_array_to_slice((size_t)3U, key, int32_t[256U], Eurydice_slice),
    int32_t[256U],
    size_t);
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    lit, core_ops_range_Range__size_t, core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      int32_t re[256U];
      memcpy(re, key[i], (size_t)256U * sizeof(int32_t));
      Eurydice_slice uu____1 = Eurydice_array_to_subslice(
        (size_t)1152U,
        out,
        ((core_ops_range_Range__size_t){ .start = i * BYTES_PER_RING_ELEMENT,
                                         .end = (i + (size_t)1U) *
                                                BYTES_PER_RING_ELEMENT }),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
      uint8_t ret0[384U];
      serialize_uncompressed_ring_element(re, ret0);
      core_slice___Slice_T___copy_from_slice(
        uu____1,
        Eurydice_array_to_slice((size_t)384U, ret0, uint8_t, Eurydice_slice),
        uint8_t,
        void*);
    }
  }
  uint8_t uu____2[1152U];
  memcpy(uu____2, out, (size_t)1152U * sizeof(uint8_t));
  memcpy(ret, uu____2, (size_t)1152U * sizeof(uint8_t));
}
__uint8_t_1152size_t__uint8_t_1184size_t_;

static void
serialize_public_key___3size_t_1152size_t_1184size_t(int32_t t_as_ntt[3U][256U],
                                                     Eurydice_slice seed_for_a,
                                                     uint8_t ret[1184U])
{
  uint8_t public_key_serialized[1184U] = { 0U };
  Eurydice_slice uu____0 =
    Eurydice_array_to_subslice((size_t)1184U,
                               public_key_serialized,
                               ((core_ops_range_Range__size_t){
                                 .start = (size_t)0U, .end = (size_t)1152U }),
                               uint8_t,
                               core_ops_range_Range__size_t,
                               Eurydice_slice);
  int32_t uu____1[3U][256U];
  memcpy(uu____1, t_as_ntt, (size_t)3U * sizeof(int32_t[256U]));
  uint8_t ret0[1152U];
  serialize_secret_key___3size_t_1152size_t(uu____1, ret0);
  core_slice___Slice_T___copy_from_slice(
    uu____0,
    Eurydice_array_to_slice((size_t)1152U, ret0, uint8_t, Eurydice_slice),
    uint8_t,
    void*);
  core_slice___Slice_T___copy_from_slice(
    Eurydice_array_to_subslice_from((size_t)1184U,
                                    public_key_serialized,
                                    (size_t)1152U,
                                    uint8_t,
                                    size_t,
                                    Eurydice_slice),
    seed_for_a,
    uint8_t,
    void*);
  uint8_t uu____2[1184U];
  memcpy(uu____2, public_key_serialized, (size_t)1184U * sizeof(uint8_t));
  memcpy(ret, uu____2, (size_t)1184U * sizeof(uint8_t));
}

static bool
validate_public_key___3size_t_1152size_t_1184size_t(uint8_t* public_key)
{
  int32_t pk[3U][256U];
  deserialize_public_key___3size_t(
    Eurydice_array_to_subslice_to((size_t)1184U,
                                  public_key,
                                  (size_t)1152U,
                                  uint8_t,
                                  size_t,
                                  Eurydice_slice),
    pk);
  int32_t uu____0[3U][256U];
  memcpy(uu____0, pk, (size_t)3U * sizeof(int32_t[256U]));
  uint8_t public_key_serialized[1184U];
  serialize_public_key___3size_t_1152size_t_1184size_t(
    uu____0,
    Eurydice_array_to_subslice_from((size_t)1184U,
                                    public_key,
                                    (size_t)1152U,
                                    uint8_t,
                                    size_t,
                                    Eurydice_slice),
    public_key_serialized);
  return core_array_equality___Array_A__N___eq(
    (size_t)1184U, public_key, public_key_serialized, uint8_t, uint8_t, bool);
}

core_option_Option__libcrux_kyber_types_MlKemPublicKey__1184size_t__
libcrux_kyber_kyber768_validate_public_key(uint8_t public_key[1184U])
{
  core_option_Option__libcrux_kyber_types_MlKemPublicKey__1184size_t__ uu____0;
  if (validate_public_key___3size_t_1152size_t_1184size_t(public_key)) {
    core_option_Option__libcrux_kyber_types_MlKemPublicKey__1184size_t__ lit;
    lit.tag = core_option_Some;
    memcpy(lit.f0, public_key, (size_t)1184U * sizeof(uint8_t));
    uu____0 = lit;
  } else {
    uu____0 =
      ((core_option_Option__libcrux_kyber_types_MlKemPublicKey__1184size_t__){
        .tag = core_option_None });
  }
  return uu____0;
}

static libcrux_digest_incremental_x4_Shake128StateX4
absorb___3size_t(uint8_t input[3U][34U])
{
  libcrux_digest_incremental_x4_Shake128StateX4 state =
    libcrux_digest_incremental_x4__libcrux__digest__incremental_x4__Shake128StateX4__new();
  Eurydice_slice data[3U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++) {
    uint8_t buf[1U] = { 0U };
    data[i] = Eurydice_array_to_slice((size_t)1U, buf, uint8_t, Eurydice_slice);
  }
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      Eurydice_slice uu____1 =
        Eurydice_array_to_slice((size_t)34U, input[i], uint8_t, Eurydice_slice);
      data[i] = uu____1;
    }
  }
  libcrux_digest_incremental_x4_Shake128StateX4* uu____2 = &state;
  Eurydice_slice uu____3[3U];
  memcpy(uu____3, data, (size_t)3U * sizeof(Eurydice_slice));
  libcrux_digest_incremental_x4__libcrux__digest__incremental_x4__Shake128StateX4__absorb_final(
    (size_t)3U, uu____2, uu____3, void*);
  return state;
}

static void
squeeze_three_blocks___3size_t(
  libcrux_digest_incremental_x4_Shake128StateX4* xof_state,
  uint8_t ret[3U][504U])
{
  uint8_t output[3U][504U];
  libcrux_digest_incremental_x4__libcrux__digest__incremental_x4__Shake128StateX4__squeeze_blocks(
    (size_t)504U, (size_t)3U, xof_state, output, void*);
  uint8_t out[3U][504U] = { { 0U } };
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      uint8_t uu____1[504U];
      memcpy(uu____1, output[i], (size_t)504U * sizeof(uint8_t));
      memcpy(out[i], uu____1, (size_t)504U * sizeof(uint8_t));
    }
  }
  uint8_t uu____2[3U][504U];
  memcpy(uu____2, out, (size_t)3U * sizeof(uint8_t[504U]));
  memcpy(ret, uu____2, (size_t)3U * sizeof(uint8_t[504U]));
}

static bool
sample_from_uniform_distribution_next___3size_t_504size_t(
  uint8_t randomness[3U][504U],
  size_t* sampled_coefficients,
  int32_t (*out)[256U])
{
  bool done = true;
  core_ops_range_Range__size_t iter0 = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter0, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      core_slice_iter_Chunks iter = core_iter_traits_collect__I__into_iter(
        core_slice___Slice_T___chunks(
          Eurydice_array_to_slice(
            (size_t)504U, randomness[i], uint8_t, Eurydice_slice),
          (size_t)3U,
          uint8_t,
          core_slice_iter_Chunks),
        core_slice_iter_Chunks,
        core_slice_iter_Chunks);
      while (true) {
        core_option_Option__Eurydice_slice_uint8_t uu____1 =
          core_slice_iter__core__slice__iter__Chunks__a__T__70__next(
            &iter, uint8_t, core_option_Option__Eurydice_slice_uint8_t);
        if (uu____1.tag == core_option_None) {
          break;
        } else {
          Eurydice_slice bytes = uu____1.f0;
          int32_t b1 =
            (int32_t)Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
          int32_t b2 =
            (int32_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
          int32_t b3 =
            (int32_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
          int32_t d1 = (b2 & (int32_t)15) << 8U | b1;
          int32_t d2 = b3 << 4U | b2 >> 4U;
          bool uu____2;
          if (d1 < FIELD_MODULUS) {
            uu____2 = sampled_coefficients[i] < COEFFICIENTS_IN_RING_ELEMENT;
          } else {
            uu____2 = false;
          }
          if (uu____2) {
            out[i][sampled_coefficients[i]] = d1;
            size_t uu____3 = i;
            sampled_coefficients[uu____3] =
              sampled_coefficients[uu____3] + (size_t)1U;
          }
          bool uu____4;
          if (d2 < FIELD_MODULUS) {
            uu____4 = sampled_coefficients[i] < COEFFICIENTS_IN_RING_ELEMENT;
          } else {
            uu____4 = false;
          }
          if (uu____4) {
            out[i][sampled_coefficients[i]] = d2;
            size_t uu____5 = i;
            sampled_coefficients[uu____5] =
              sampled_coefficients[uu____5] + (size_t)1U;
          }
        }
      }
      if (sampled_coefficients[i] < COEFFICIENTS_IN_RING_ELEMENT) {
        done = false;
      }
    }
  }
  return done;
}

static void
squeeze_block___3size_t(
  libcrux_digest_incremental_x4_Shake128StateX4* xof_state,
  uint8_t ret[3U][168U])
{
  uint8_t output[3U][168U];
  libcrux_digest_incremental_x4__libcrux__digest__incremental_x4__Shake128StateX4__squeeze_blocks(
    (size_t)168U, (size_t)3U, xof_state, output, void*);
  uint8_t out[3U][168U] = { { 0U } };
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      uint8_t uu____1[168U];
      memcpy(uu____1, output[i], (size_t)168U * sizeof(uint8_t));
      memcpy(out[i], uu____1, (size_t)168U * sizeof(uint8_t));
    }
  }
  uint8_t uu____2[3U][168U];
  memcpy(uu____2, out, (size_t)3U * sizeof(uint8_t[168U]));
  memcpy(ret, uu____2, (size_t)3U * sizeof(uint8_t[168U]));
}

static bool
sample_from_uniform_distribution_next___3size_t_168size_t(
  uint8_t randomness[3U][168U],
  size_t* sampled_coefficients,
  int32_t (*out)[256U])
{
  bool done = true;
  core_ops_range_Range__size_t iter0 = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter0, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      core_slice_iter_Chunks iter = core_iter_traits_collect__I__into_iter(
        core_slice___Slice_T___chunks(
          Eurydice_array_to_slice(
            (size_t)168U, randomness[i], uint8_t, Eurydice_slice),
          (size_t)3U,
          uint8_t,
          core_slice_iter_Chunks),
        core_slice_iter_Chunks,
        core_slice_iter_Chunks);
      while (true) {
        core_option_Option__Eurydice_slice_uint8_t uu____1 =
          core_slice_iter__core__slice__iter__Chunks__a__T__70__next(
            &iter, uint8_t, core_option_Option__Eurydice_slice_uint8_t);
        if (uu____1.tag == core_option_None) {
          break;
        } else {
          Eurydice_slice bytes = uu____1.f0;
          int32_t b1 =
            (int32_t)Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
          int32_t b2 =
            (int32_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
          int32_t b3 =
            (int32_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
          int32_t d1 = (b2 & (int32_t)15) << 8U | b1;
          int32_t d2 = b3 << 4U | b2 >> 4U;
          bool uu____2;
          if (d1 < FIELD_MODULUS) {
            uu____2 = sampled_coefficients[i] < COEFFICIENTS_IN_RING_ELEMENT;
          } else {
            uu____2 = false;
          }
          if (uu____2) {
            out[i][sampled_coefficients[i]] = d1;
            size_t uu____3 = i;
            sampled_coefficients[uu____3] =
              sampled_coefficients[uu____3] + (size_t)1U;
          }
          bool uu____4;
          if (d2 < FIELD_MODULUS) {
            uu____4 = sampled_coefficients[i] < COEFFICIENTS_IN_RING_ELEMENT;
          } else {
            uu____4 = false;
          }
          if (uu____4) {
            out[i][sampled_coefficients[i]] = d2;
            size_t uu____5 = i;
            sampled_coefficients[uu____5] =
              sampled_coefficients[uu____5] + (size_t)1U;
          }
        }
      }
      if (sampled_coefficients[i] < COEFFICIENTS_IN_RING_ELEMENT) {
        done = false;
      }
    }
  }
  return done;
}

static void
sample_from_xof___3size_t(uint8_t seeds[3U][34U], int32_t ret[3U][256U])
{
  size_t sampled_coefficients[3U] = { 0U };
  int32_t out[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++) {
    memcpy(out[i], ZERO, (size_t)256U * sizeof(int32_t));
  }
  uint8_t uu____0[3U][34U];
  memcpy(uu____0, seeds, (size_t)3U * sizeof(uint8_t[34U]));
  libcrux_digest_incremental_x4_Shake128StateX4 xof_state =
    absorb___3size_t(uu____0);
  uint8_t randomness0[3U][504U];
  squeeze_three_blocks___3size_t(&xof_state, randomness0);
  uint8_t uu____1[3U][504U];
  memcpy(uu____1, randomness0, (size_t)3U * sizeof(uint8_t[504U]));
  bool done = sample_from_uniform_distribution_next___3size_t_504size_t(
    uu____1, sampled_coefficients, out);
  while (true) {
    if (!!done) {
      break;
    }
    uint8_t randomness[3U][168U];
    squeeze_block___3size_t(&xof_state, randomness);
    uint8_t uu____2[3U][168U];
    memcpy(uu____2, randomness, (size_t)3U * sizeof(uint8_t[168U]));
    done = sample_from_uniform_distribution_next___3size_t_168size_t(
      uu____2, sampled_coefficients, out);
  }
  free_state(xof_state);
  int32_t uu____3[3U][256U];
  memcpy(uu____3, out, (size_t)3U * sizeof(int32_t[256U]));
  memcpy(ret, uu____3, (size_t)3U * sizeof(int32_t[256U]));
}

static void
sample_matrix_A___3size_t(uint8_t seed[34U],
                          bool transpose,
                          int32_t ret[3U][3U][256U])
{
  int32_t A_transpose[3U][3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++) {
    memcpy(A_transpose[i][0U], ZERO, (size_t)256U * sizeof(int32_t));
    memcpy(A_transpose[i][1U], ZERO, (size_t)256U * sizeof(int32_t));
    memcpy(A_transpose[i][2U], ZERO, (size_t)256U * sizeof(int32_t));
  }
  core_ops_range_Range__size_t iter0 = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter0, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i0 = uu____0.f0;
      uint8_t uu____1[34U];
      memcpy(uu____1, seed, (size_t)34U * sizeof(uint8_t));
      uint8_t seeds[3U][34U];
      for (size_t i = (size_t)0U; i < (size_t)3U; i++) {
        memcpy(seeds[i], uu____1, (size_t)34U * sizeof(uint8_t));
      }
      core_ops_range_Range__size_t iter1 =
        core_iter_traits_collect__I__into_iter(
          ((core_ops_range_Range__size_t){ .start = (size_t)0U,
                                           .end = (size_t)3U }),
          core_ops_range_Range__size_t,
          core_ops_range_Range__size_t);
      while (true) {
        core_option_Option__size_t uu____2 =
          core_iter_range__core__ops__range__Range_A__3__next(
            &iter1, size_t, core_option_Option__size_t);
        if (uu____2.tag == core_option_None) {
          break;
        } else {
          size_t j = uu____2.f0;
          seeds[j][32U] = (uint8_t)i0;
          seeds[j][33U] = (uint8_t)j;
        }
      }
      uint8_t uu____3[3U][34U];
      memcpy(uu____3, seeds, (size_t)3U * sizeof(uint8_t[34U]));
      int32_t sampled[3U][256U];
      sample_from_xof___3size_t(uu____3, sampled);
      core_ops_range_Range__size_t iter =
        core_iter_traits_collect__I__into_iter(
          ((core_ops_range_Range__size_t){ .start = (size_t)0U,
                                           .end = (size_t)3U }),
          core_ops_range_Range__size_t,
          core_ops_range_Range__size_t);
      while (true) {
        core_option_Option__size_t uu____4 =
          core_iter_range__core__ops__range__Range_A__3__next(
            &iter, size_t, core_option_Option__size_t);
        if (uu____4.tag == core_option_None) {
          break;
        } else {
          size_t j = uu____4.f0;
          if (transpose) {
            memcpy(
              A_transpose[j][i0], sampled[j], (size_t)256U * sizeof(int32_t));
          } else {
            memcpy(
              A_transpose[i0][j], sampled[j], (size_t)256U * sizeof(int32_t));
          }
        }
      }
    }
  }
  int32_t uu____5[3U][3U][256U];
  memcpy(uu____5, A_transpose, (size_t)3U * sizeof(int32_t[3U][256U]));
  memcpy(ret, uu____5, (size_t)3U * sizeof(int32_t[3U][256U]));
}

static void
into_padded_array___34size_t(Eurydice_slice slice, uint8_t ret[34U])
{
  uint8_t out[34U] = { 0U };
  uint8_t* uu____0 = out;
  core_slice___Slice_T___copy_from_slice(
    Eurydice_array_to_subslice(
      (size_t)34U,
      uu____0,
      ((core_ops_range_Range__size_t){
        .start = (size_t)0U,
        .end = core_slice___Slice_T___len(slice, uint8_t, size_t) }),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    slice,
    uint8_t,
    void*);
  uint8_t uu____1[34U];
  memcpy(uu____1, out, (size_t)34U * sizeof(uint8_t));
  memcpy(ret, uu____1, (size_t)34U * sizeof(uint8_t));
}

static void
into_padded_array___33size_t(Eurydice_slice slice, uint8_t ret[33U])
{
  uint8_t out[33U] = { 0U };
  uint8_t* uu____0 = out;
  core_slice___Slice_T___copy_from_slice(
    Eurydice_array_to_subslice(
      (size_t)33U,
      uu____0,
      ((core_ops_range_Range__size_t){
        .start = (size_t)0U,
        .end = core_slice___Slice_T___len(slice, uint8_t, size_t) }),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    slice,
    uint8_t,
    void*);
  uint8_t uu____1[33U];
  memcpy(uu____1, out, (size_t)33U * sizeof(uint8_t));
  memcpy(ret, uu____1, (size_t)33U * sizeof(uint8_t));
}

static void
PRF___128size_t(Eurydice_slice input, uint8_t ret[128U])
{
  uint8_t ret0[128U];
  libcrux_digest_shake256((size_t)128U, input, ret0, void*);
  memcpy(ret, ret0, (size_t)128U * sizeof(uint8_t));
}

static void
sample_from_binomial_distribution___2size_t(Eurydice_slice randomness,
                                            int32_t ret[256U])
{
  int32_t uu____0[256U];
  sample_from_binomial_distribution_2(randomness, uu____0);
  memcpy(ret, uu____0, (size_t)256U * sizeof(int32_t));
}

typedef struct
  __libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__uint8_t_s
{
  int32_t fst[3U][256U];
  uint8_t snd;
} __libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__uint8_t;

static __libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__uint8_t
sample_vector_cbd_then_ntt___3size_t_2size_t_128size_t(uint8_t prf_input[33U],
                                                       uint8_t domain_separator)
{
  int32_t re_as_ntt[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++) {
    memcpy(re_as_ntt[i], ZERO, (size_t)256U * sizeof(int32_t));
  }
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      prf_input[32U] = domain_separator;
      domain_separator = (uint32_t)domain_separator + 1U;
      uint8_t prf_output[128U];
      PRF___128size_t(Eurydice_array_to_slice(
                        (size_t)33U, prf_input, uint8_t, Eurydice_slice),
                      prf_output);
      int32_t r[256U];
      sample_from_binomial_distribution___2size_t(
        Eurydice_array_to_slice(
          (size_t)128U, prf_output, uint8_t, Eurydice_slice),
        r);
      int32_t uu____1[256U];
      ntt_binomially_sampled_ring_element(r, uu____1);
      memcpy(re_as_ntt[i], uu____1, (size_t)256U * sizeof(int32_t));
    }
  }
  int32_t uu____2[3U][256U];
  memcpy(uu____2, re_as_ntt, (size_t)3U * sizeof(int32_t[256U]));
  __libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__uint8_t lit;
  memcpy(lit.fst, uu____2, (size_t)3U * sizeof(int32_t[256U]));
  lit.snd = domain_separator;
  return lit;
}

static void
add_to_ring_element___3size_t(int32_t lhs[256U],
                              int32_t (*rhs)[256U],
                              int32_t ret[256U])
{
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(
    Eurydice_array_to_slice((size_t)256U, lhs, int32_t, Eurydice_slice),
    int32_t,
    size_t);
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    lit, core_ops_range_Range__size_t, core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      size_t uu____1 = i;
      lhs[uu____1] = lhs[uu____1] + rhs[0U][i];
    }
  }
  memcpy(ret, lhs, (size_t)256U * sizeof(int32_t));
}

static void
compute_As_plus_e___3size_t(int32_t (*matrix_A)[3U][256U],
                            int32_t (*s_as_ntt)[256U],
                            int32_t (*error_as_ntt)[256U],
                            int32_t ret[3U][256U])
{
  int32_t result[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++) {
    memcpy(result[i], ZERO, (size_t)256U * sizeof(int32_t));
  }
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = core_slice___Slice_T___len(
    Eurydice_array_to_slice(
      (size_t)3U, matrix_A, Eurydice_error_t_cg_array, Eurydice_slice),
    int32_t[3U][256U],
    size_t);
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    lit0, core_ops_range_Range__size_t, core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      int32_t(*row)[256U] = matrix_A[i];
      core_ops_range_Range__size_t lit;
      lit.start = (size_t)0U;
      lit.end = core_slice___Slice_T___len(
        Eurydice_array_to_slice((size_t)3U, row, int32_t[256U], Eurydice_slice),
        int32_t[256U],
        size_t);
      core_ops_range_Range__size_t iter0 =
        core_iter_traits_collect__I__into_iter(
          lit, core_ops_range_Range__size_t, core_ops_range_Range__size_t);
      while (true) {
        core_option_Option__size_t uu____1 =
          core_iter_range__core__ops__range__Range_A__3__next(
            &iter0, size_t, core_option_Option__size_t);
        if (uu____1.tag == core_option_None) {
          break;
        } else {
          size_t j = uu____1.f0;
          int32_t(*matrix_element)[256U] = &row[j];
          int32_t product[256U];
          ntt_multiply(matrix_element, &s_as_ntt[j], product);
          int32_t uu____2[256U];
          add_to_ring_element___3size_t(result[i], &product, uu____2);
          memcpy(result[i], uu____2, (size_t)256U * sizeof(int32_t));
        }
      }
      core_ops_range_Range__size_t iter1 =
        core_iter_traits_collect__I__into_iter(
          ((core_ops_range_Range__size_t){
            .start = (size_t)0U, .end = COEFFICIENTS_IN_RING_ELEMENT }),
          core_ops_range_Range__size_t,
          core_ops_range_Range__size_t);
      while (true) {
        core_option_Option__size_t uu____3 =
          core_iter_range__core__ops__range__Range_A__3__next(
            &iter1, size_t, core_option_Option__size_t);
        if (uu____3.tag == core_option_None) {
          break;
        } else {
          size_t j = uu____3.f0;
          int32_t coefficient_normal_form = to_standard_domain(result[i][j]);
          int32_t uu____4 =
            barrett_reduce(coefficient_normal_form + error_as_ntt[i][j]);
          result[i][j] = uu____4;
        }
      }
    }
  }
  int32_t uu____5[3U][256U];
  memcpy(uu____5, result, (size_t)3U * sizeof(int32_t[256U]));
  memcpy(ret, uu____5, (size_t)3U * sizeof(int32_t[256U]));
}

typedef struct __uint8_t_1152size_t__uint8_t_1184size_t__s
{
  uint8_t fst[1152U];
  uint8_t snd[1184U];
} __uint8_t_1152size_t__uint8_t_1184size_t_;

static __uint8_t_1152size_t__uint8_t_1184size_t_
generate_keypair___3size_t_1152size_t_1184size_t_1152size_t_2size_t_128size_t(
  Eurydice_slice key_generation_seed)
{
  uint8_t hashed[64U];
  G(key_generation_seed, hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t uu____0 =
    core_slice___Slice_T___split_at(
      Eurydice_array_to_slice((size_t)64U, hashed, uint8_t, Eurydice_slice),
      (size_t)32U,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice seed_for_A = uu____0.fst;
  Eurydice_slice seed_for_secret_and_error = uu____0.snd;
  int32_t A_transpose[3U][3U][256U];
  uint8_t ret[34U];
  into_padded_array___34size_t(seed_for_A, ret);
  sample_matrix_A___3size_t(ret, true, A_transpose);
  uint8_t prf_input[33U];
  into_padded_array___33size_t(seed_for_secret_and_error, prf_input);
  uint8_t uu____1[33U];
  memcpy(uu____1, prf_input, (size_t)33U * sizeof(uint8_t));
  __libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__uint8_t uu____2 =
    sample_vector_cbd_then_ntt___3size_t_2size_t_128size_t(uu____1, 0U);
  int32_t secret_as_ntt[3U][256U];
  memcpy(secret_as_ntt, uu____2.fst, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t domain_separator = uu____2.snd;
  uint8_t uu____3[33U];
  memcpy(uu____3, prf_input, (size_t)33U * sizeof (uint8_t));
  int32_t error_as_ntt[3U][256U];
  memcpy(error_as_ntt,
         sample_vector_cbd_then_ntt___3size_t_2size_t_128size_t(
           uu____3, domain_separator)
           .fst,
         (size_t)3U * sizeof(int32_t[256U]));
  int32_t t_as_ntt[3U][256U];
  compute_As_plus_e___3size_t(
    A_transpose, secret_as_ntt, error_as_ntt, t_as_ntt);
  int32_t uu____4[3U][256U];
  memcpy(uu____4, t_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t public_key_serialized[1184U];
  serialize_public_key___3size_t_1152size_t_1184size_t(
    uu____4, seed_for_A, public_key_serialized);
  int32_t uu____5[3U][256U];
  memcpy(uu____5, secret_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t secret_key_serialized[1152U];
  serialize_secret_key___3size_t_1152size_t(uu____5, secret_key_serialized);
  uint8_t uu____6[1152U];
  memcpy(uu____6, secret_key_serialized, (size_t)1152U * sizeof (uint8_t));
  uint8_t uu____7[1184U];
  memcpy(uu____7, public_key_serialized, (size_t)1184U * sizeof(uint8_t));
  __uint8_t_1152size_t__uint8_t_1184size_t_ lit;
  memcpy(lit.fst, uu____6, (size_t)1152U * sizeof(uint8_t));
  memcpy(lit.snd, uu____7, (size_t)1184U * sizeof(uint8_t));
  return lit;
}

static void
serialize_kem_secret_key___2400size_t(Eurydice_slice private_key,
                                      Eurydice_slice public_key,
                                      Eurydice_slice implicit_rejection_value,
                                      uint8_t ret[2400U])
{
  uint8_t out[2400U] = { 0U };
  size_t pointer = (size_t)0U;
  uint8_t *uu____0 = out;
  size_t uu____1 = pointer;
  size_t uu____2 = pointer;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)2400U,
      uu____0,
      (
        (core_ops_range_Range__size_t){
          .start = uu____1,
          .end = uu____2 + core_slice___Slice_T___len(private_key, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    private_key,
    uint8_t,
    void *);
  pointer = pointer + core_slice___Slice_T___len(private_key, uint8_t, size_t);
  uint8_t *uu____3 = out;
  size_t uu____4 = pointer;
  size_t uu____5 = pointer;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)2400U,
      uu____3,
      (
        (core_ops_range_Range__size_t){
          .start = uu____4,
          .end = uu____5 + core_slice___Slice_T___len(public_key, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    public_key,
    uint8_t,
    void *);
  pointer = pointer + core_slice___Slice_T___len(public_key, uint8_t, size_t);
  Eurydice_slice uu____6 = Eurydice_array_to_subslice(
    (size_t)2400U,
    out,
    ((core_ops_range_Range__size_t){ .start = pointer,
                                     .end = pointer + H_DIGEST_SIZE }),
    uint8_t,
    core_ops_range_Range__size_t,
    Eurydice_slice);
  uint8_t ret0[32U];
  H(public_key, ret0);
  core_slice___Slice_T___copy_from_slice(
    uu____6,
    Eurydice_array_to_slice((size_t)32U, ret0, uint8_t, Eurydice_slice),
    uint8_t,
    void*);
  pointer = pointer + H_DIGEST_SIZE;
  uint8_t* uu____7 = out;
  size_t uu____8 = pointer;
  size_t uu____9 = pointer;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)2400U,
      uu____7,
      (
        (core_ops_range_Range__size_t){
          .start = uu____8,
          .end = uu____9 + core_slice___Slice_T___len(implicit_rejection_value, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    implicit_rejection_value,
    uint8_t,
    void *);
  uint8_t uu____10[2400U];
  memcpy(uu____10, out, (size_t)2400U * sizeof (uint8_t));
  memcpy(ret, uu____10, (size_t)2400U * sizeof (uint8_t));
}

typedef uint8_t MlKemPrivateKey___2400size_t[2400U];

static void
from___2400size_t(uint8_t value[2400U], uint8_t ret[2400U])
{
  uint8_t uu____0[2400U];
  memcpy(uu____0, value, (size_t)2400U * sizeof (uint8_t));
  memcpy(ret, uu____0, (size_t)2400U * sizeof (uint8_t));
}

static libcrux_kyber_types_MlKemKeyPair___2400size_t_1184size_t
from___2400size_t_1184size_t(uint8_t sk[2400U], uint8_t pk[1184U])
{
  libcrux_kyber_types_MlKemKeyPair___2400size_t_1184size_t lit;
  memcpy(lit.sk, sk, (size_t)2400U * sizeof(uint8_t));
  memcpy(lit.pk, pk, (size_t)1184U * sizeof(uint8_t));
  return lit;
}

static libcrux_kyber_types_MlKemKeyPair___2400size_t_1184size_t
generate_keypair___3size_t_1152size_t_2400size_t_1184size_t_1152size_t_2size_t_128size_t(
  uint8_t randomness[64U])
{
  Eurydice_slice ind_cpa_keypair_randomness = Eurydice_array_to_subslice(
    (size_t)64U,
    randomness,
    ((core_ops_range_Range__size_t){ .start = (size_t)0U,
                                     .end = CPA_PKE_KEY_GENERATION_SEED_SIZE }),
    uint8_t,
    core_ops_range_Range__size_t,
    Eurydice_slice);
  Eurydice_slice implicit_rejection_value =
    Eurydice_array_to_subslice_from((size_t)64U,
                                    randomness,
                                    CPA_PKE_KEY_GENERATION_SEED_SIZE,
                                    uint8_t,
                                    size_t,
                                    Eurydice_slice);
  __uint8_t_1152size_t__uint8_t_1184size_t_ uu____0 =
    generate_keypair___3size_t_1152size_t_1184size_t_1152size_t_2size_t_128size_t(
      ind_cpa_keypair_randomness);
  uint8_t ind_cpa_private_key[1152U];
  memcpy(ind_cpa_private_key, uu____0.fst, (size_t)1152U * sizeof (uint8_t));
  uint8_t public_key[1184U];
  memcpy(public_key, uu____0.snd, (size_t)1184U * sizeof (uint8_t));
  Eurydice_slice
  uu____1 = Eurydice_array_to_slice((size_t)1152U, ind_cpa_private_key, uint8_t, Eurydice_slice);
  uint8_t secret_key_serialized[2400U];
  serialize_kem_secret_key___2400size_t(
    uu____1,
    Eurydice_array_to_slice((size_t)1184U, public_key, uint8_t, Eurydice_slice),
    implicit_rejection_value,
    secret_key_serialized);
  uint8_t uu____2[2400U];
  memcpy(uu____2, secret_key_serialized, (size_t)2400U * sizeof (uint8_t));
  uint8_t private_key[2400U];
  from___2400size_t(uu____2, private_key);
  uint8_t uu____3[2400U];
  memcpy(uu____3, private_key, (size_t)2400U * sizeof (uint8_t));
  uint8_t uu____4[1184U];
  memcpy(uu____4, public_key, (size_t)1184U * sizeof(uint8_t));
  return from___2400size_t_1184size_t(uu____3, uu____4);
}

libcrux_kyber_types_MlKemKeyPair___2400size_t_1184size_t
libcrux_kyber_kyber768_generate_key_pair(uint8_t randomness[64U])
{
  uint8_t uu____0[64U];
  memcpy(uu____0, randomness, (size_t)64U * sizeof(uint8_t));
  return generate_keypair___3size_t_1152size_t_2400size_t_1184size_t_1152size_t_2size_t_128size_t(
    uu____0);
}

static void
into_padded_array___64size_t(Eurydice_slice slice, uint8_t ret[64U])
{
  uint8_t out[64U] = { 0U };
  uint8_t* uu____0 = out;
  core_slice___Slice_T___copy_from_slice(
    Eurydice_array_to_subslice(
      (size_t)64U,
      uu____0,
      (
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = core_slice___Slice_T___len(slice, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    slice,
    uint8_t,
    void *);
  uint8_t uu____1[64U];
  memcpy(uu____1, out, (size_t)64U * sizeof (uint8_t));
  memcpy(ret, uu____1, (size_t)64U * sizeof (uint8_t));
}

static uint8_t*
as_slice___1184size_t(uint8_t (*self)[1184U])
{
  return self[0U];
}

static void
sample_ring_element_cbd___3size_t_128size_t_2size_t(uint8_t* prf_input,
                                                    uint8_t* domain_separator,
                                                    int32_t ret[3U][256U])
{
  int32_t error_1[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++) {
    memcpy(error_1[i], ZERO, (size_t)256U * sizeof(int32_t));
  }
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      prf_input[32U] = domain_separator[0U];
      domain_separator[0U] = (uint32_t)domain_separator[0U] + 1U;
      uint8_t prf_output[128U];
      PRF___128size_t(Eurydice_array_to_slice(
                        (size_t)33U, prf_input, uint8_t, Eurydice_slice),
                      prf_output);
      int32_t uu____1[256U];
      sample_from_binomial_distribution___2size_t(
        Eurydice_array_to_slice(
          (size_t)128U, prf_output, uint8_t, Eurydice_slice),
        uu____1);
      memcpy(error_1[i], uu____1, (size_t)256U * sizeof (int32_t));
    }
  }
  int32_t uu____2[3U][256U];
  memcpy(uu____2, error_1, (size_t)3U * sizeof (int32_t [256U]));
  memcpy(ret, uu____2, (size_t)3U * sizeof (int32_t [256U]));
}

static void
invert_ntt_montgomery___3size_t(int32_t re[256U], int32_t ret[256U])
{
  size_t zeta_i = COEFFICIENTS_IN_RING_ELEMENT / (size_t)2U;
  invert_ntt_at_layer(&zeta_i, re, (size_t)1U, re);
  invert_ntt_at_layer(&zeta_i, re, (size_t)2U, re);
  invert_ntt_at_layer(&zeta_i, re, (size_t)3U, re);
  invert_ntt_at_layer(&zeta_i, re, (size_t)4U, re);
  invert_ntt_at_layer(&zeta_i, re, (size_t)5U, re);
  invert_ntt_at_layer(&zeta_i, re, (size_t)6U, re);
  invert_ntt_at_layer(&zeta_i, re, (size_t)7U, re);
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)2U }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      int32_t uu____1 = barrett_reduce(re[i]);
      re[i] = uu____1;
    }
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

static void
compute_vector_u___3size_t(int32_t (*a_as_ntt)[3U][256U],
                           int32_t (*r_as_ntt)[256U],
                           int32_t (*error_1)[256U],
                           int32_t ret[3U][256U])
{
  int32_t result[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++) {
    memcpy(result[i], ZERO, (size_t)256U * sizeof(int32_t));
  }
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = core_slice___Slice_T___len(
    Eurydice_array_to_slice(
      (size_t)3U, a_as_ntt, Eurydice_error_t_cg_array, Eurydice_slice),
    int32_t[3U][256U],
    size_t);
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    lit0, core_ops_range_Range__size_t, core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      int32_t (*row)[256U] = a_as_ntt[i];
      core_ops_range_Range__size_t lit;
      lit.start = (size_t)0U;
      lit.end = core_slice___Slice_T___len(
        Eurydice_array_to_slice((size_t)3U, row, int32_t[256U], Eurydice_slice),
        int32_t[256U],
        size_t);
      core_ops_range_Range__size_t iter0 =
        core_iter_traits_collect__I__into_iter(
          lit, core_ops_range_Range__size_t, core_ops_range_Range__size_t);
      while (true) {
        core_option_Option__size_t uu____1 =
          core_iter_range__core__ops__range__Range_A__3__next(
            &iter0, size_t, core_option_Option__size_t);
        if (uu____1.tag == core_option_None) {
          break;
        } else {
          size_t j = uu____1.f0;
          int32_t (*a_element)[256U] = &row[j];
          int32_t product[256U];
          ntt_multiply(a_element, &r_as_ntt[j], product);
          int32_t uu____2[256U];
          add_to_ring_element___3size_t(result[i], &product, uu____2);
          memcpy(result[i], uu____2, (size_t)256U * sizeof(int32_t));
        }
      }
      int32_t uu____3[256U];
      invert_ntt_montgomery___3size_t(result[i], uu____3);
      memcpy(result[i], uu____3, (size_t)256U * sizeof(int32_t));
      core_ops_range_Range__size_t iter1 =
        core_iter_traits_collect__I__into_iter(
          ((core_ops_range_Range__size_t){
            .start = (size_t)0U, .end = COEFFICIENTS_IN_RING_ELEMENT }),
          core_ops_range_Range__size_t,
          core_ops_range_Range__size_t);
      while (true) {
        core_option_Option__size_t uu____4 =
          core_iter_range__core__ops__range__Range_A__3__next(
            &iter1, size_t, core_option_Option__size_t);
        if (uu____4.tag == core_option_None) {
          break;
        } else {
          size_t j = uu____4.f0;
          int32_t coefficient_normal_form =
            montgomery_reduce(result[i][j] * (int32_t)1441);
          int32_t uu____5 =
            barrett_reduce(coefficient_normal_form + error_1[i][j]);
          result[i][j] = uu____5;
        }
      }
    }
  }
  int32_t uu____6[3U][256U];
  memcpy(uu____6, result, (size_t)3U * sizeof (int32_t [256U]));
  memcpy(ret, uu____6, (size_t)3U * sizeof (int32_t [256U]));
}

static void
compute_ring_element_v___3size_t(int32_t (*t_as_ntt)[256U],
                                 int32_t (*r_as_ntt)[256U],
                                 int32_t (*error_2)[256U],
                                 int32_t (*message)[256U],
                                 int32_t ret[256U])
{
  int32_t result[256U];
  memcpy(result, ZERO, (size_t)256U * sizeof(int32_t));
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      int32_t product[256U];
      ntt_multiply(&t_as_ntt[i], &r_as_ntt[i], product);
      add_to_ring_element___3size_t(result, &product, result);
    }
  }
  invert_ntt_montgomery___3size_t(result, result);
  core_ops_range_Range__size_t iter0 = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){ .start = (size_t)0U,
                                     .end = COEFFICIENTS_IN_RING_ELEMENT }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____1 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter0, size_t, core_option_Option__size_t);
    if (uu____1.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____1.f0;
      int32_t coefficient_normal_form =
        montgomery_reduce(result[i] * (int32_t)1441);
      int32_t uu____2 = barrett_reduce(coefficient_normal_form +
                                       error_2[0U][i] + message[0U][i]);
      result[i] = uu____2;
    }
  }
  memcpy(ret, result, (size_t)256U * sizeof (int32_t));
}

static void
compress_then_serialize_10___320size_t(int32_t re[256U], uint8_t ret[320U])
{
  uint8_t serialized[320U] = { 0U };
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t, Eurydice_slice),
      int32_t,
      size_t) /
    (size_t)4U;
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    lit, core_ops_range_Range__size_t, core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      Eurydice_slice coefficients = Eurydice_array_to_subslice(
        (size_t)256U,
        re,
        ((core_ops_range_Range__size_t){ .start = i * (size_t)4U,
                                         .end = i * (size_t)4U + (size_t)4U }),
        int32_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
      int32_t coefficient1 = compress_ciphertext_coefficient(
        10U,
        to_unsigned_representative(
          Eurydice_slice_index(coefficients, (size_t)0U, int32_t, int32_t)));
      int32_t coefficient2 = compress_ciphertext_coefficient(
        10U,
        to_unsigned_representative(
          Eurydice_slice_index(coefficients, (size_t)1U, int32_t, int32_t)));
      int32_t coefficient3 = compress_ciphertext_coefficient(
        10U,
        to_unsigned_representative(
          Eurydice_slice_index(coefficients, (size_t)2U, int32_t, int32_t)));
      int32_t coefficient4 = compress_ciphertext_coefficient(
        10U,
        to_unsigned_representative(
          Eurydice_slice_index(coefficients, (size_t)3U, int32_t, int32_t)));
      __uint8_t_uint8_t_uint8_t_uint8_t_uint8_t uu____1 =
        compress_coefficients_10(
          coefficient1, coefficient2, coefficient3, coefficient4);
      uint8_t coef1 = uu____1.fst;
      uint8_t coef2 = uu____1.snd;
      uint8_t coef3 = uu____1.thd;
      uint8_t coef4 = uu____1.f3;
      uint8_t coef5 = uu____1.f4;
      serialized[(size_t)5U * i] = coef1;
      serialized[(size_t)5U * i + (size_t)1U] = coef2;
      serialized[(size_t)5U * i + (size_t)2U] = coef3;
      serialized[(size_t)5U * i + (size_t)3U] = coef4;
      serialized[(size_t)5U * i + (size_t)4U] = coef5;
    }
  }
  uint8_t uu____2[320U];
  memcpy(uu____2, serialized, (size_t)320U * sizeof (uint8_t));
  memcpy(ret, uu____2, (size_t)320U * sizeof (uint8_t));
}

static void
compress_then_serialize_11___320size_t(int32_t re[256U], uint8_t ret[320U])
{
  uint8_t serialized[320U] = { 0U };
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t, Eurydice_slice),
      int32_t,
      size_t) /
    (size_t)8U;
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    lit, core_ops_range_Range__size_t, core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      Eurydice_slice coefficients = Eurydice_array_to_subslice(
        (size_t)256U,
        re,
        ((core_ops_range_Range__size_t){ .start = i * (size_t)8U,
                                         .end = i * (size_t)8U + (size_t)8U }),
        int32_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
      int32_t coefficient1 = compress_ciphertext_coefficient(
        11U,
        to_unsigned_representative(
          Eurydice_slice_index(coefficients, (size_t)0U, int32_t, int32_t)));
      int32_t coefficient2 = compress_ciphertext_coefficient(
        11U,
        to_unsigned_representative(
          Eurydice_slice_index(coefficients, (size_t)1U, int32_t, int32_t)));
      int32_t coefficient3 = compress_ciphertext_coefficient(
        11U,
        to_unsigned_representative(
          Eurydice_slice_index(coefficients, (size_t)2U, int32_t, int32_t)));
      int32_t coefficient4 = compress_ciphertext_coefficient(
        11U,
        to_unsigned_representative(
          Eurydice_slice_index(coefficients, (size_t)3U, int32_t, int32_t)));
      int32_t coefficient5 = compress_ciphertext_coefficient(
        11U,
        to_unsigned_representative(
          Eurydice_slice_index(coefficients, (size_t)4U, int32_t, int32_t)));
      int32_t coefficient6 = compress_ciphertext_coefficient(
        11U,
        to_unsigned_representative(
          Eurydice_slice_index(coefficients, (size_t)5U, int32_t, int32_t)));
      int32_t coefficient7 = compress_ciphertext_coefficient(
        11U,
        to_unsigned_representative(
          Eurydice_slice_index(coefficients, (size_t)6U, int32_t, int32_t)));
      int32_t coefficient8 = compress_ciphertext_coefficient(
        11U,
        to_unsigned_representative(
          Eurydice_slice_index(coefficients, (size_t)7U, int32_t, int32_t)));
      __uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
        uu____1 = compress_coefficients_11(coefficient1,
                                           coefficient2,
                                           coefficient3,
                                           coefficient4,
                                           coefficient5,
                                           coefficient6,
                                           coefficient7,
                                           coefficient8);
      uint8_t coef1 = uu____1.fst;
      uint8_t coef2 = uu____1.snd;
      uint8_t coef3 = uu____1.thd;
      uint8_t coef4 = uu____1.f3;
      uint8_t coef5 = uu____1.f4;
      uint8_t coef6 = uu____1.f5;
      uint8_t coef7 = uu____1.f6;
      uint8_t coef8 = uu____1.f7;
      uint8_t coef9 = uu____1.f8;
      uint8_t coef10 = uu____1.f9;
      uint8_t coef11 = uu____1.f10;
      serialized[(size_t)11U * i] = coef1;
      serialized[(size_t)11U * i + (size_t)1U] = coef2;
      serialized[(size_t)11U * i + (size_t)2U] = coef3;
      serialized[(size_t)11U * i + (size_t)3U] = coef4;
      serialized[(size_t)11U * i + (size_t)4U] = coef5;
      serialized[(size_t)11U * i + (size_t)5U] = coef6;
      serialized[(size_t)11U * i + (size_t)6U] = coef7;
      serialized[(size_t)11U * i + (size_t)7U] = coef8;
      serialized[(size_t)11U * i + (size_t)8U] = coef9;
      serialized[(size_t)11U * i + (size_t)9U] = coef10;
      serialized[(size_t)11U * i + (size_t)10U] = coef11;
    }
  }
  uint8_t uu____2[320U];
  memcpy(uu____2, serialized, (size_t)320U * sizeof (uint8_t));
  memcpy(ret, uu____2, (size_t)320U * sizeof (uint8_t));
}

static void
compress_then_serialize_ring_element_u___10size_t_320size_t(int32_t re[256U],
                                                            uint8_t ret[320U])
{
  uint8_t uu____0[320U];
  compress_then_serialize_10___320size_t(re, uu____0);
  memcpy(ret, uu____0, (size_t)320U * sizeof(uint8_t));
}

static void
compress_then_serialize_u___3size_t_960size_t_10size_t_320size_t(
  int32_t input[3U][256U],
  uint8_t ret[960U]
)
{
  uint8_t out[960U] = { 0U };
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(
    Eurydice_array_to_slice((size_t)3U, input, int32_t[256U], Eurydice_slice),
    int32_t[256U],
    size_t);
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    lit, core_ops_range_Range__size_t, core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      int32_t re[256U];
      memcpy(re, input[i], (size_t)256U * sizeof(int32_t));
      Eurydice_slice uu____1 = Eurydice_array_to_subslice(
        (size_t)960U,
        out,
        ((core_ops_range_Range__size_t){
          .start = i * ((size_t)960U / (size_t)3U),
          .end = (i + (size_t)1U) * ((size_t)960U / (size_t)3U) }),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
      uint8_t ret0[320U];
      compress_then_serialize_ring_element_u___10size_t_320size_t(re, ret0);
      core_slice___Slice_T___copy_from_slice(
        uu____1,
        Eurydice_array_to_slice((size_t)320U, ret0, uint8_t, Eurydice_slice),
        uint8_t,
        void*);
    }
  }
  uint8_t uu____2[960U];
  memcpy(uu____2, out, (size_t)960U * sizeof(uint8_t));
  memcpy(ret, uu____2, (size_t)960U * sizeof(uint8_t));
}

static void
compress_then_serialize_4___128size_t(int32_t re[256U], uint8_t ret[128U])
{
  uint8_t serialized[128U] = { 0U };
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(
      Eurydice_array_to_slice((size_t)256U, re, int32_t, Eurydice_slice),
      int32_t,
      size_t) /
    (size_t)2U;
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    lit, core_ops_range_Range__size_t, core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      Eurydice_slice coefficients = Eurydice_array_to_subslice(
        (size_t)256U,
        re,
        ((core_ops_range_Range__size_t){ .start = i * (size_t)2U,
                                         .end = i * (size_t)2U + (size_t)2U }),
        int32_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
      uint8_t coefficient1 = (uint8_t)compress_ciphertext_coefficient(
        4U,
        to_unsigned_representative(
          Eurydice_slice_index(coefficients, (size_t)0U, int32_t, int32_t)));
      uint8_t coefficient2 = (uint8_t)compress_ciphertext_coefficient(
        4U,
        to_unsigned_representative(
          Eurydice_slice_index(coefficients, (size_t)1U, int32_t, int32_t)));
      serialized[i] = (uint32_t)coefficient2 << 4U | (uint32_t)coefficient1;
    }
  }
  uint8_t uu____1[128U];
  memcpy(uu____1, serialized, (size_t)128U * sizeof (uint8_t));
  memcpy(ret, uu____1, (size_t)128U * sizeof (uint8_t));
}

static void
compress_then_serialize_5___128size_t(int32_t re[256U], uint8_t ret[128U])
{
  uint8_t serialized[128U] = { 0U };
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t, Eurydice_slice),
      int32_t,
      size_t) /
    (size_t)8U;
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    lit, core_ops_range_Range__size_t, core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      Eurydice_slice coefficients = Eurydice_array_to_subslice(
        (size_t)256U,
        re,
        ((core_ops_range_Range__size_t){ .start = i * (size_t)8U,
                                         .end = i * (size_t)8U + (size_t)8U }),
        int32_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
      uint8_t coefficient1 = (uint8_t)compress_ciphertext_coefficient(
        5U,
        to_unsigned_representative(
          Eurydice_slice_index(coefficients, (size_t)0U, int32_t, int32_t)));
      uint8_t coefficient2 = (uint8_t)compress_ciphertext_coefficient(
        5U,
        to_unsigned_representative(
          Eurydice_slice_index(coefficients, (size_t)1U, int32_t, int32_t)));
      uint8_t coefficient3 = (uint8_t)compress_ciphertext_coefficient(
        5U,
        to_unsigned_representative(
          Eurydice_slice_index(coefficients, (size_t)2U, int32_t, int32_t)));
      uint8_t coefficient4 = (uint8_t)compress_ciphertext_coefficient(
        5U,
        to_unsigned_representative(
          Eurydice_slice_index(coefficients, (size_t)3U, int32_t, int32_t)));
      uint8_t coefficient5 = (uint8_t)compress_ciphertext_coefficient(
        5U,
        to_unsigned_representative(
          Eurydice_slice_index(coefficients, (size_t)4U, int32_t, int32_t)));
      uint8_t coefficient6 = (uint8_t)compress_ciphertext_coefficient(
        5U,
        to_unsigned_representative(
          Eurydice_slice_index(coefficients, (size_t)5U, int32_t, int32_t)));
      uint8_t coefficient7 = (uint8_t)compress_ciphertext_coefficient(
        5U,
        to_unsigned_representative(
          Eurydice_slice_index(coefficients, (size_t)6U, int32_t, int32_t)));
      uint8_t coefficient8 = (uint8_t)compress_ciphertext_coefficient(
        5U,
        to_unsigned_representative(
          Eurydice_slice_index(coefficients, (size_t)7U, int32_t, int32_t)));
      __uint8_t_uint8_t_uint8_t_uint8_t_uint8_t uu____1 =
        compress_coefficients_5(coefficient2,
                                coefficient1,
                                coefficient4,
                                coefficient3,
                                coefficient5,
                                coefficient7,
                                coefficient6,
                                coefficient8);
      uint8_t coef1 = uu____1.fst;
      uint8_t coef2 = uu____1.snd;
      uint8_t coef3 = uu____1.thd;
      uint8_t coef4 = uu____1.f3;
      uint8_t coef5 = uu____1.f4;
      serialized[(size_t)5U * i] = coef1;
      serialized[(size_t)5U * i + (size_t)1U] = coef2;
      serialized[(size_t)5U * i + (size_t)2U] = coef3;
      serialized[(size_t)5U * i + (size_t)3U] = coef4;
      serialized[(size_t)5U * i + (size_t)4U] = coef5;
    }
  }
  uint8_t uu____2[128U];
  memcpy(uu____2, serialized, (size_t)128U * sizeof (uint8_t));
  memcpy(ret, uu____2, (size_t)128U * sizeof (uint8_t));
}

static void
compress_then_serialize_ring_element_v___4size_t_128size_t(int32_t re[256U],
                                                           uint8_t ret[128U])
{
  uint8_t uu____0[128U];
  compress_then_serialize_4___128size_t(re, uu____0);
  memcpy(ret, uu____0, (size_t)128U * sizeof(uint8_t));
}

static void
into_padded_array___1088size_t(Eurydice_slice slice, uint8_t ret[1088U])
{
  uint8_t out[1088U] = { 0U };
  uint8_t* uu____0 = out;
  core_slice___Slice_T___copy_from_slice(
    Eurydice_array_to_subslice(
      (size_t)1088U,
      uu____0,
      (
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = core_slice___Slice_T___len(slice, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    slice,
    uint8_t,
    void *);
  uint8_t uu____1[1088U];
  memcpy(uu____1, out, (size_t)1088U * sizeof (uint8_t));
  memcpy(ret, uu____1, (size_t)1088U * sizeof (uint8_t));
}

static void
encrypt___3size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(
  Eurydice_slice public_key,
  uint8_t message[32U],
  Eurydice_slice randomness,
  uint8_t ret[1088U]
)
{
  int32_t t_as_ntt[3U][256U];
  deserialize_public_key___3size_t(
    Eurydice_slice_subslice_to(
      public_key, (size_t)1152U, uint8_t, size_t, Eurydice_slice),
    t_as_ntt);
  Eurydice_slice seed = Eurydice_slice_subslice_from(
    public_key, (size_t)1152U, uint8_t, size_t, Eurydice_slice);
  int32_t A_transpose[3U][3U][256U];
  uint8_t ret0[34U];
  into_padded_array___34size_t(seed, ret0);
  sample_matrix_A___3size_t(ret0, false, A_transpose);
  uint8_t prf_input[33U];
  into_padded_array___33size_t(randomness, prf_input);
  uint8_t uu____0[33U];
  memcpy(uu____0, prf_input, (size_t)33U * sizeof(uint8_t));
  __libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__uint8_t uu____1 =
    sample_vector_cbd_then_ntt___3size_t_2size_t_128size_t(uu____0, 0U);
  int32_t r_as_ntt[3U][256U];
  memcpy(r_as_ntt, uu____1.fst, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t domain_separator = uu____1.snd;
  int32_t error_1[3U][256U];
  sample_ring_element_cbd___3size_t_128size_t_2size_t(
    prf_input, &domain_separator, error_1);
  prf_input[32U] = domain_separator;
  uint8_t prf_output[128U];
  PRF___128size_t(
    Eurydice_array_to_slice((size_t)33U, prf_input, uint8_t, Eurydice_slice),
    prf_output);
  int32_t error_2[256U];
  sample_from_binomial_distribution___2size_t(
    Eurydice_array_to_slice((size_t)128U, prf_output, uint8_t, Eurydice_slice),
    error_2);
  int32_t u[3U][256U];
  compute_vector_u___3size_t(A_transpose, r_as_ntt, error_1, u);
  uint8_t uu____2[32U];
  memcpy(uu____2, message, (size_t)32U * sizeof (uint8_t));
  int32_t message_as_ring_element[256U];
  deserialize_then_decompress_message(uu____2, message_as_ring_element);
  int32_t v[256U];
  compute_ring_element_v___3size_t(
    t_as_ntt, r_as_ntt, &error_2, &message_as_ring_element, v);
  int32_t uu____3[3U][256U];
  memcpy(uu____3, u, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t c1[960U];
  compress_then_serialize_u___3size_t_960size_t_10size_t_320size_t(uu____3, c1);
  uint8_t c2[128U];
  compress_then_serialize_ring_element_v___4size_t_128size_t(v, c2);
  uint8_t ciphertext[1088U];
  into_padded_array___1088size_t(
    Eurydice_array_to_slice((size_t)960U, c1, uint8_t, Eurydice_slice),
    ciphertext);
  Eurydice_slice
  uu____4 =
    Eurydice_array_to_subslice_from((size_t)1088U,
      ciphertext,
      (size_t)960U,
      uint8_t,
      size_t,
      Eurydice_slice);
  core_slice___Slice_T___copy_from_slice(uu____4,
    core_array___Array_T__N__23__as_slice((size_t)128U, c2, uint8_t, Eurydice_slice),
    uint8_t,
    void *);
  uint8_t uu____5[1088U];
  memcpy(uu____5, ciphertext, (size_t)1088U * sizeof (uint8_t));
  memcpy(ret, uu____5, (size_t)1088U * sizeof (uint8_t));
}

typedef uint8_t MlKemCiphertext___1088size_t[1088U];

static K___libcrux_kyber_types_MlKemCiphertext__1088size_t___uint8_t_32size_t_
encapsulate___3size_t_1088size_t_1184size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(
  uint8_t (*public_key)[1184U],
  uint8_t randomness[32U]
)
{
  uint8_t to_hash[64U];
  into_padded_array___64size_t(
    Eurydice_array_to_slice((size_t)32U, randomness, uint8_t, Eurydice_slice),
    to_hash);
  Eurydice_slice uu____0 = Eurydice_array_to_subslice_from(
    (size_t)64U, to_hash, H_DIGEST_SIZE, uint8_t, size_t, Eurydice_slice);
  uint8_t ret[32U];
  H(Eurydice_array_to_slice((size_t)1184U,
                            as_slice___1184size_t(public_key),
                            uint8_t,
                            Eurydice_slice),
    ret);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)32U, ret, uint8_t, Eurydice_slice),
    uint8_t,
    void *);
  uint8_t hashed[64U];
  G(Eurydice_array_to_slice((size_t)64U, to_hash, uint8_t, Eurydice_slice),
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t uu____1 =
    core_slice___Slice_T___split_at(
      Eurydice_array_to_slice((size_t)64U, hashed, uint8_t, Eurydice_slice),
      SHARED_SECRET_SIZE,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice shared_secret = uu____1.fst;
  Eurydice_slice pseudorandomness = uu____1.snd;
  Eurydice_slice uu____2 = Eurydice_array_to_slice(
    (size_t)1184U, as_slice___1184size_t(public_key), uint8_t, Eurydice_slice);
  uint8_t uu____3[32U];
  memcpy(uu____3, randomness, (size_t)32U * sizeof (uint8_t));
  uint8_t ciphertext[1088U];
  encrypt___3size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(
    uu____2, uu____3, pseudorandomness, ciphertext);
  uint8_t shared_secret_array[32U] = { 0U };
  core_slice___Slice_T___copy_from_slice(
    Eurydice_array_to_slice(
      (size_t)32U, shared_secret_array, uint8_t, Eurydice_slice),
    shared_secret,
    uint8_t,
    void*);
  uint8_t uu____4[1088U];
  memcpy(uu____4, ciphertext, (size_t)1088U * sizeof(uint8_t));
  uint8_t uu____5[1088U];
  memcpy(uu____5, uu____4, (size_t)1088U * sizeof(uint8_t));
  uint8_t uu____6[32U];
  memcpy(uu____6, shared_secret_array, (size_t)32U * sizeof(uint8_t));
  K___libcrux_kyber_types_MlKemCiphertext__1088size_t___uint8_t_32size_t_ lit;
  memcpy(lit.fst, uu____5, (size_t)1088U * sizeof(uint8_t));
  memcpy(lit.snd, uu____6, (size_t)32U * sizeof(uint8_t));
  return lit;
}

K___libcrux_kyber_types_MlKemCiphertext__1088size_t___uint8_t_32size_t_
libcrux_kyber_kyber768_encapsulate(uint8_t (*public_key)[1184U],
                                   uint8_t randomness[32U])
{
  uint8_t (*uu____0)[1184U] = public_key;
  uint8_t uu____1[32U];
  memcpy(uu____1, randomness, (size_t)32U * sizeof(uint8_t));
  return encapsulate___3size_t_1088size_t_1184size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(
    uu____0, uu____1);
}

static K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
split_at___2400size_t(uint8_t (*self)[2400U], size_t mid)
{
  return
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)2400U,
        self[0U],
        uint8_t,
        Eurydice_slice),
      mid,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
}

static void
deserialize_then_decompress_ring_element_u___10size_t(Eurydice_slice serialized,
                                                      int32_t ret[256U])
{
  int32_t uu____0[256U];
  deserialize_then_decompress_10(serialized, uu____0);
  memcpy(ret, uu____0, (size_t)256U * sizeof(int32_t));
}

static void
ntt_vector_u___10size_t(int32_t re[256U], int32_t ret[256U])
{
  size_t zeta_i = (size_t)0U;
  ntt_at_layer_3328(&zeta_i, re, (size_t)7U, re);
  ntt_at_layer_3328(&zeta_i, re, (size_t)6U, re);
  ntt_at_layer_3328(&zeta_i, re, (size_t)5U, re);
  ntt_at_layer_3328(&zeta_i, re, (size_t)4U, re);
  ntt_at_layer_3328(&zeta_i, re, (size_t)3U, re);
  ntt_at_layer_3328(&zeta_i, re, (size_t)2U, re);
  ntt_at_layer_3328(&zeta_i, re, (size_t)1U, re);
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){ .start = (size_t)0U,
                                     .end = COEFFICIENTS_IN_RING_ELEMENT }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      int32_t uu____1 = barrett_reduce(re[i]);
      re[i] = uu____1;
    }
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

static void
deserialize_then_decompress_u___3size_t_1088size_t_10size_t(
  uint8_t* ciphertext,
  int32_t ret[3U][256U])
{
  int32_t u_as_ntt[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++) {
    memcpy(u_as_ntt[i], ZERO, (size_t)256U * sizeof(int32_t));
  }
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){
      .start = (size_t)0U,
      .end = core_slice___Slice_T___len(
               Eurydice_array_to_slice(
                 (size_t)1088U, ciphertext, uint8_t, Eurydice_slice),
               uint8_t,
               size_t) /
             (COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U) }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      Eurydice_slice u_bytes = Eurydice_array_to_subslice(
        (size_t)1088U,
        ciphertext,
        ((core_ops_range_Range__size_t){
          .start =
            i * (COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U),
          .end = i * (COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U) +
                 COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U }),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
      int32_t u[256U];
      deserialize_then_decompress_ring_element_u___10size_t(u_bytes, u);
      int32_t uu____1[256U];
      ntt_vector_u___10size_t(u, uu____1);
      memcpy(u_as_ntt[i], uu____1, (size_t)256U * sizeof(int32_t));
    }
  }
  int32_t uu____2[3U][256U];
  memcpy(uu____2, u_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
  memcpy(ret, uu____2, (size_t)3U * sizeof (int32_t [256U]));
}

static void
deserialize_then_decompress_ring_element_v___4size_t(Eurydice_slice serialized,
                                                     int32_t ret[256U])
{
  int32_t uu____0[256U];
  deserialize_then_decompress_4(serialized, uu____0);
  memcpy(ret, uu____0, (size_t)256U * sizeof(int32_t));
}

static void
deserialize_secret_key___3size_t(Eurydice_slice secret_key,
                                 int32_t ret[3U][256U])
{
  int32_t secret_as_ntt[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++) {
    memcpy(secret_as_ntt[i], ZERO, (size_t)256U * sizeof(int32_t));
  }
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){
      .start = (size_t)0U,
      .end = core_slice___Slice_T___len(secret_key, uint8_t, size_t) /
             BYTES_PER_RING_ELEMENT }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      Eurydice_slice secret_bytes = Eurydice_slice_subslice(
        secret_key,
        ((core_ops_range_Range__size_t){ .start = i * BYTES_PER_RING_ELEMENT,
                                         .end = i * BYTES_PER_RING_ELEMENT +
                                                BYTES_PER_RING_ELEMENT }),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
      int32_t uu____1[256U];
      deserialize_to_uncompressed_ring_element(secret_bytes, uu____1);
      memcpy(secret_as_ntt[i], uu____1, (size_t)256U * sizeof(int32_t));
    }
  }
  int32_t uu____2[3U][256U];
  memcpy(uu____2, secret_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
  memcpy(ret, uu____2, (size_t)3U * sizeof (int32_t [256U]));
}

static void
compute_message___3size_t(int32_t (*v)[256U],
                          int32_t (*secret_as_ntt)[256U],
                          int32_t (*u_as_ntt)[256U],
                          int32_t ret[256U])
{
  int32_t result[256U];
  memcpy(result, ZERO, (size_t)256U * sizeof(int32_t));
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      int32_t product[256U];
      ntt_multiply(&secret_as_ntt[i], &u_as_ntt[i], product);
      add_to_ring_element___3size_t(result, &product, result);
    }
  }
  invert_ntt_montgomery___3size_t(result, result);
  core_ops_range_Range__size_t iter0 = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){ .start = (size_t)0U,
                                     .end = COEFFICIENTS_IN_RING_ELEMENT }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____1 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter0, size_t, core_option_Option__size_t);
    if (uu____1.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____1.f0;
      int32_t coefficient_normal_form =
        montgomery_reduce(result[i] * (int32_t)1441);
      int32_t uu____2 = barrett_reduce(v[0U][i] - coefficient_normal_form);
      result[i] = uu____2;
    }
  }
  memcpy(ret, result, (size_t)256U * sizeof (int32_t));
}

static void
decrypt___3size_t_1088size_t_960size_t_10size_t_4size_t(
  Eurydice_slice secret_key,
  uint8_t *ciphertext,
  uint8_t ret[32U]
)
{
  int32_t u_as_ntt[3U][256U];
  deserialize_then_decompress_u___3size_t_1088size_t_10size_t(ciphertext,
                                                              u_as_ntt);
  int32_t v[256U];
  deserialize_then_decompress_ring_element_v___4size_t(
    Eurydice_array_to_subslice_from(
      (size_t)1088U, ciphertext, (size_t)960U, uint8_t, size_t, Eurydice_slice),
    v);
  int32_t secret_as_ntt[3U][256U];
  deserialize_secret_key___3size_t(secret_key, secret_as_ntt);
  int32_t message[256U];
  compute_message___3size_t(&v, secret_as_ntt, u_as_ntt, message);
  uint8_t ret0[32U];
  compress_then_serialize_message(message, ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof(uint8_t));
}

static void
into_padded_array___1120size_t(Eurydice_slice slice, uint8_t ret[1120U])
{
  uint8_t out[1120U] = { 0U };
  uint8_t* uu____0 = out;
  core_slice___Slice_T___copy_from_slice(
    Eurydice_array_to_subslice(
      (size_t)1120U,
      uu____0,
      (
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = core_slice___Slice_T___len(slice, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    slice,
    uint8_t,
    void *);
  uint8_t uu____1[1120U];
  memcpy(uu____1, out, (size_t)1120U * sizeof (uint8_t));
  memcpy(ret, uu____1, (size_t)1120U * sizeof (uint8_t));
}

static Eurydice_slice
as_ref___1088size_t(uint8_t (*self)[1088U])
{
  return Eurydice_array_to_slice((size_t)1088U, self[0U], uint8_t, Eurydice_slice);
}

static void
PRF___32size_t(Eurydice_slice input, uint8_t ret[32U])
{
  uint8_t ret0[32U];
  libcrux_digest_shake256((size_t)32U, input, ret0, void *);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

static uint8_t
compare_ciphertexts_in_constant_time___1088size_t(Eurydice_slice lhs,
                                                  Eurydice_slice rhs)
{
  uint8_t r = 0U;
  core_ops_range_Range__size_t iter = core_iter_traits_collect__I__into_iter(
    ((core_ops_range_Range__size_t){ .start = (size_t)0U,
                                     .end = (size_t)1088U }),
    core_ops_range_Range__size_t,
    core_ops_range_Range__size_t);
  while (true) {
    core_option_Option__size_t uu____0 =
      core_iter_range__core__ops__range__Range_A__3__next(
        &iter, size_t, core_option_Option__size_t);
    if (uu____0.tag == core_option_None) {
      break;
    } else {
      size_t i = uu____0.f0;
      uint8_t uu____1 = Eurydice_slice_index(lhs, i, uint8_t, uint8_t);
      r =
        (uint32_t)r
        | ((uint32_t)uu____1 ^ (uint32_t)Eurydice_slice_index(rhs, i, uint8_t, uint8_t));
    }
  }
  return is_non_zero(r);
}

static void
decapsulate___3size_t_2400size_t_1152size_t_1184size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t_1120size_t(
  uint8_t (*secret_key)[2400U],
  uint8_t (*ciphertext)[1088U],
  uint8_t ret[32U]
)
{
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t uu____0 =
    split_at___2400size_t(secret_key, (size_t)1152U);
  Eurydice_slice ind_cpa_secret_key = uu____0.fst;
  Eurydice_slice secret_key0 = uu____0.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 =
    core_slice___Slice_T___split_at(secret_key0,
      (size_t)1184U,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice ind_cpa_public_key = uu____1.fst;
  Eurydice_slice secret_key1 = uu____1.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t uu____2 =
    core_slice___Slice_T___split_at(
      secret_key1,
      H_DIGEST_SIZE,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice ind_cpa_public_key_hash = uu____2.fst;
  Eurydice_slice implicit_rejection_value = uu____2.snd;
  uint8_t decrypted[32U];
  decrypt___3size_t_1088size_t_960size_t_10size_t_4size_t(
    ind_cpa_secret_key, ciphertext[0U], decrypted);
  uint8_t to_hash0[64U];
  into_padded_array___64size_t(
    Eurydice_array_to_slice((size_t)32U, decrypted, uint8_t, Eurydice_slice),
    to_hash0);
  core_slice___Slice_T___copy_from_slice(
    Eurydice_array_to_subslice_from((size_t)64U,
                                    to_hash0,
                                    SHARED_SECRET_SIZE,
                                    uint8_t,
                                    size_t,
                                    Eurydice_slice),
    ind_cpa_public_key_hash,
    uint8_t,
    void *);
  uint8_t hashed[64U];
  G(Eurydice_array_to_slice((size_t)64U, to_hash0, uint8_t, Eurydice_slice),
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t uu____3 =
    core_slice___Slice_T___split_at(
      Eurydice_array_to_slice((size_t)64U, hashed, uint8_t, Eurydice_slice),
      SHARED_SECRET_SIZE,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice shared_secret = uu____3.fst;
  Eurydice_slice pseudorandomness = uu____3.snd;
  uint8_t to_hash[1120U];
  into_padded_array___1120size_t(implicit_rejection_value, to_hash);
  Eurydice_slice uu____4 = Eurydice_array_to_subslice_from((size_t)1120U,
                                                           to_hash,
                                                           SHARED_SECRET_SIZE,
                                                           uint8_t,
                                                           size_t,
                                                           Eurydice_slice);
  core_slice___Slice_T___copy_from_slice(
    uu____4, as_ref___1088size_t(ciphertext), uint8_t, void*);
  uint8_t implicit_rejection_shared_secret[32U];
  PRF___32size_t(
    Eurydice_array_to_slice((size_t)1120U, to_hash, uint8_t, Eurydice_slice),
    implicit_rejection_shared_secret);
  Eurydice_slice uu____5 = ind_cpa_public_key;
  uint8_t uu____6[32U];
  memcpy(uu____6, decrypted, (size_t)32U * sizeof (uint8_t));
  uint8_t expected_ciphertext[1088U];
  encrypt___3size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(
    uu____5, uu____6, pseudorandomness, expected_ciphertext);
  Eurydice_slice uu____7 = as_ref___1088size_t(ciphertext);
  uint8_t selector = compare_ciphertexts_in_constant_time___1088size_t(
    uu____7,
    Eurydice_array_to_slice(
      (size_t)1088U, expected_ciphertext, uint8_t, Eurydice_slice));
  Eurydice_slice uu____8 = shared_secret;
  uint8_t ret0[32U];
  select_shared_secret_in_constant_time(
    uu____8,
    Eurydice_array_to_slice(
      (size_t)32U, implicit_rejection_shared_secret, uint8_t, Eurydice_slice),
    selector,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_kyber_kyber768_decapsulate(uint8_t (*secret_key)[2400U],
                                   uint8_t (*ciphertext)[1088U],
                                   uint8_t ret[32U])
{
  uint8_t ret0[32U];
  decapsulate___3size_t_2400size_t_1152size_t_1184size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t_1120size_t(
    secret_key, ciphertext, ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof(uint8_t));
}

