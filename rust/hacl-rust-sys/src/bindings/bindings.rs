/* automatically generated by rust-bindgen 0.59.2 */

pub const Spec_Hash_Definitions_SHA2_224: u32 = 0;
pub const Spec_Hash_Definitions_SHA2_256: u32 = 1;
pub const Spec_Hash_Definitions_SHA2_384: u32 = 2;
pub const Spec_Hash_Definitions_SHA2_512: u32 = 3;
pub const Spec_Hash_Definitions_SHA1: u32 = 4;
pub const Spec_Hash_Definitions_MD5: u32 = 5;
pub const Spec_Hash_Definitions_Blake2S: u32 = 6;
pub const Spec_Hash_Definitions_Blake2B: u32 = 7;
pub const Spec_Hash_Definitions_SHA3_256: u32 = 8;
pub const Spec_FFDHE_FFDHE2048: u32 = 0;
pub const Spec_FFDHE_FFDHE3072: u32 = 1;
pub const Spec_FFDHE_FFDHE4096: u32 = 2;
pub const Spec_FFDHE_FFDHE6144: u32 = 3;
pub const Spec_FFDHE_FFDHE8192: u32 = 4;
pub const Spec_Agile_AEAD_AES128_GCM: u32 = 0;
pub const Spec_Agile_AEAD_AES256_GCM: u32 = 1;
pub const Spec_Agile_AEAD_CHACHA20_POLY1305: u32 = 2;
pub const Spec_Agile_AEAD_AES128_CCM: u32 = 3;
pub const Spec_Agile_AEAD_AES256_CCM: u32 = 4;
pub const Spec_Agile_AEAD_AES128_CCM8: u32 = 5;
pub const Spec_Agile_AEAD_AES256_CCM8: u32 = 6;
pub const Spec_Frodo_Params_SHAKE128: u32 = 0;
pub const Spec_Frodo_Params_AES128: u32 = 1;
pub const EverCrypt_Error_Success: u32 = 0;
pub const EverCrypt_Error_UnsupportedAlgorithm: u32 = 1;
pub const EverCrypt_Error_InvalidKey: u32 = 2;
pub const EverCrypt_Error_AuthenticationFailure: u32 = 3;
pub const EverCrypt_Error_InvalidIVLength: u32 = 4;
pub const EverCrypt_Error_DecodeError: u32 = 5;
pub const EverCrypt_Error_MaximumLengthExceeded: u32 = 6;
pub type C_String_t = *const ::std::os::raw::c_char;
pub type Spec_Hash_Definitions_hash_alg = u8;
pub type Spec_FFDHE_ffdhe_alg = u8;
pub type Spec_Agile_AEAD_alg = u8;
pub type Spec_Frodo_Params_frodo_gen_a = u8;
pub type EverCrypt_Error_error_code = u8;
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_shaext() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_aesni() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_pclmulqdq() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_avx2() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_avx() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_bmi2() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_adx() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_sse() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_movbe() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_rdrand() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_avx512() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_recall();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_init();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_avx2();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_avx();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_bmi2();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_adx();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_shaext();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_aesni();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_pclmulqdq();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_sse();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_movbe();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_rdrand();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_avx512();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_vec128() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_vec256() -> bool;
}
extern "C" {
    pub fn EverCrypt_AEAD_uu___is_Ek(
        a: Spec_Agile_AEAD_alg,
        projectee: EverCrypt_AEAD_state_s,
    ) -> bool;
}
extern "C" {
    #[doc = "Return the algorithm used in the AEAD state."]
    #[doc = ""]
    #[doc = "@param s State of the AEAD algorithm."]
    #[doc = ""]
    #[doc = "@return Algorithm used in the AEAD state."]
    pub fn EverCrypt_AEAD_alg_of_state(s: *mut EverCrypt_AEAD_state_s) -> Spec_Agile_AEAD_alg;
}
extern "C" {
    #[doc = "Create the required AEAD state for the algorithm."]
    #[doc = ""]
    #[doc = "Note: The caller must free the AEAD state by calling `EverCrypt_AEAD_free`."]
    #[doc = ""]
    #[doc = "@param a The argument `a` must be either of:"]
    #[doc = " `Spec_Agile_AEAD_AES128_GCM` (KEY_LEN=16),"]
    #[doc = " `Spec_Agile_AEAD_AES256_GCM` (KEY_LEN=32), or"]
    #[doc = " `Spec_Agile_AEAD_CHACHA20_POLY1305` (KEY_LEN=32)."]
    #[doc = "@param dst Pointer to a pointer where the address of the allocated AEAD state will be written to."]
    #[doc = "@param k Pointer to `KEY_LEN` bytes of memory where the key is read from. The size depends on the used algorithm, see above."]
    #[doc = ""]
    #[doc = "@return The function returns `EverCrypt_Error_Success` on success or"]
    #[doc = "`EverCrypt_Error_UnsupportedAlgorithm` in case of a bad algorithm identifier."]
    #[doc = "(See `EverCrypt_Error.h`.)"]
    pub fn EverCrypt_AEAD_create_in(
        a: Spec_Agile_AEAD_alg,
        dst: *mut *mut EverCrypt_AEAD_state_s,
        k: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    #[doc = "Encrypt and authenticate a message (`plain`) with associated data (`ad`)."]
    #[doc = ""]
    #[doc = "@param s Pointer to the The AEAD state created by `EverCrypt_AEAD_create_in`. It already contains the encryption key."]
    #[doc = "@param iv Pointer to `iv_len` bytes of memory where the nonce is read from."]
    #[doc = "@param iv_len Length of the nonce. Note: ChaCha20Poly1305 requires a 12 byte nonce."]
    #[doc = "@param ad Pointer to `ad_len` bytes of memory where the associated data is read from."]
    #[doc = "@param ad_len Length of the associated data."]
    #[doc = "@param plain Pointer to `plain_len` bytes of memory where the to-be-encrypted plaintext is read from."]
    #[doc = "@param plain_len Length of the to-be-encrypted plaintext."]
    #[doc = "@param cipher Pointer to `plain_len` bytes of memory where the ciphertext is written to."]
    #[doc = "@param tag Pointer to `TAG_LEN` bytes of memory where the tag is written to."]
    #[doc = "The length of the `tag` must be of a suitable length for the chosen algorithm:"]
    #[doc = " `Spec_Agile_AEAD_AES128_GCM` (TAG_LEN=16)"]
    #[doc = " `Spec_Agile_AEAD_AES256_GCM` (TAG_LEN=16)"]
    #[doc = " `Spec_Agile_AEAD_CHACHA20_POLY1305` (TAG_LEN=16)"]
    #[doc = ""]
    #[doc = "@return `EverCrypt_AEAD_encrypt` may return either `EverCrypt_Error_Success` or `EverCrypt_Error_InvalidKey` (`EverCrypt_error.h`). The latter is returned if and only if the `s` parameter is `NULL`."]
    pub fn EverCrypt_AEAD_encrypt(
        s: *mut EverCrypt_AEAD_state_s,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        plain: *mut u8,
        plain_len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    #[doc = "WARNING: this function doesn't perform any dynamic"]
    #[doc = "hardware check. You MUST make sure your hardware supports the"]
    #[doc = "implementation of AESGCM. Besides, this function was not designed"]
    #[doc = "for cross-compilation: if you compile it on a system which doesn't"]
    #[doc = "support Vale, it will compile it to a function which makes the"]
    #[doc = "program exit."]
    pub fn EverCrypt_AEAD_encrypt_expand_aes128_gcm_no_check(
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        plain: *mut u8,
        plain_len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    #[doc = "WARNING: this function doesn't perform any dynamic"]
    #[doc = "hardware check. You MUST make sure your hardware supports the"]
    #[doc = "implementation of AESGCM. Besides, this function was not designed"]
    #[doc = "for cross-compilation: if you compile it on a system which doesn't"]
    #[doc = "support Vale, it will compile it to a function which makes the"]
    #[doc = "program exit."]
    pub fn EverCrypt_AEAD_encrypt_expand_aes256_gcm_no_check(
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        plain: *mut u8,
        plain_len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    pub fn EverCrypt_AEAD_encrypt_expand_aes128_gcm(
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        plain: *mut u8,
        plain_len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    pub fn EverCrypt_AEAD_encrypt_expand_aes256_gcm(
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        plain: *mut u8,
        plain_len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    pub fn EverCrypt_AEAD_encrypt_expand_chacha20_poly1305(
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        plain: *mut u8,
        plain_len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    pub fn EverCrypt_AEAD_encrypt_expand(
        a: Spec_Agile_AEAD_alg,
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        plain: *mut u8,
        plain_len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    #[doc = "Verify the authenticity of `ad` || `cipher` and decrypt `cipher` into `dst`."]
    #[doc = ""]
    #[doc = "@param s Pointer to the The AEAD state created by `EverCrypt_AEAD_create_in`. It already contains the encryption key."]
    #[doc = "@param iv Pointer to `iv_len` bytes of memory where the nonce is read from."]
    #[doc = "@param iv_len Length of the nonce. Note: ChaCha20Poly1305 requires a 12 byte nonce."]
    #[doc = "@param ad Pointer to `ad_len` bytes of memory where the associated data is read from."]
    #[doc = "@param ad_len Length of the associated data."]
    #[doc = "@param cipher Pointer to `cipher_len` bytes of memory where the ciphertext is read from."]
    #[doc = "@param cipher_len Length of the ciphertext."]
    #[doc = "@param tag Pointer to `TAG_LEN` bytes of memory where the tag is read from."]
    #[doc = "The length of the `tag` must be of a suitable length for the chosen algorithm:"]
    #[doc = " `Spec_Agile_AEAD_AES128_GCM` (TAG_LEN=16)"]
    #[doc = " `Spec_Agile_AEAD_AES256_GCM` (TAG_LEN=16)"]
    #[doc = " `Spec_Agile_AEAD_CHACHA20_POLY1305` (TAG_LEN=16)"]
    #[doc = "@param dst Pointer to `cipher_len` bytes of memory where the decrypted plaintext will be written to."]
    #[doc = ""]
    #[doc = "@return `EverCrypt_AEAD_decrypt` returns ..."]
    #[doc = ""]
    #[doc = " `EverCrypt_Error_Success`"]
    #[doc = ""]
    #[doc = "... on success and either of ..."]
    #[doc = ""]
    #[doc = " `EverCrypt_Error_InvalidKey` (returned if and only if the `s` parameter is `NULL`),"]
    #[doc = " `EverCrypt_Error_InvalidIVLength` (see note about requirements on IV size above), or"]
    #[doc = " `EverCrypt_Error_AuthenticationFailure` (in case the ciphertext could not be authenticated, e.g., due to modifications)"]
    #[doc = ""]
    #[doc = "... on failure (`EverCrypt_error.h`)."]
    #[doc = ""]
    #[doc = "Upon success, the plaintext will be written into `dst`."]
    pub fn EverCrypt_AEAD_decrypt(
        s: *mut EverCrypt_AEAD_state_s,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        cipher: *mut u8,
        cipher_len: u32,
        tag: *mut u8,
        dst: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    #[doc = "WARNING: this function doesn't perform any dynamic"]
    #[doc = "hardware check. You MUST make sure your hardware supports the"]
    #[doc = "implementation of AESGCM. Besides, this function was not designed"]
    #[doc = "for cross-compilation: if you compile it on a system which doesn't"]
    #[doc = "support Vale, it will compile it to a function which makes the"]
    #[doc = "program exit."]
    pub fn EverCrypt_AEAD_decrypt_expand_aes128_gcm_no_check(
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        cipher: *mut u8,
        cipher_len: u32,
        tag: *mut u8,
        dst: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    #[doc = "WARNING: this function doesn't perform any dynamic"]
    #[doc = "hardware check. You MUST make sure your hardware supports the"]
    #[doc = "implementation of AESGCM. Besides, this function was not designed"]
    #[doc = "for cross-compilation: if you compile it on a system which doesn't"]
    #[doc = "support Vale, it will compile it to a function which makes the"]
    #[doc = "program exit."]
    pub fn EverCrypt_AEAD_decrypt_expand_aes256_gcm_no_check(
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        cipher: *mut u8,
        cipher_len: u32,
        tag: *mut u8,
        dst: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    pub fn EverCrypt_AEAD_decrypt_expand_aes128_gcm(
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        cipher: *mut u8,
        cipher_len: u32,
        tag: *mut u8,
        dst: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    pub fn EverCrypt_AEAD_decrypt_expand_aes256_gcm(
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        cipher: *mut u8,
        cipher_len: u32,
        tag: *mut u8,
        dst: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    pub fn EverCrypt_AEAD_decrypt_expand_chacha20_poly1305(
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        cipher: *mut u8,
        cipher_len: u32,
        tag: *mut u8,
        dst: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    pub fn EverCrypt_AEAD_decrypt_expand(
        a: Spec_Agile_AEAD_alg,
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        cipher: *mut u8,
        cipher_len: u32,
        tag: *mut u8,
        dst: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    #[doc = "Cleanup and free the AEAD state."]
    #[doc = ""]
    #[doc = "@param s State of the AEAD algorithm."]
    pub fn EverCrypt_AEAD_free(s: *mut EverCrypt_AEAD_state_s);
}
extern "C" {
    #[doc = "Calculate a public point from a secret/private key."]
    #[doc = ""]
    #[doc = "This computes a scalar multiplication of the secret/private key with the curve's basepoint."]
    #[doc = ""]
    #[doc = "@param pub Pointer to 32 bytes of memory where the resulting point is written to."]
    #[doc = "@param priv Pointer to 32 bytes of memory where the secret/private key is read from."]
    pub fn EverCrypt_Curve25519_secret_to_public(pub_: *mut u8, priv_: *mut u8);
}
extern "C" {
    #[doc = "Compute the scalar multiple of a point."]
    #[doc = ""]
    #[doc = "@param shared Pointer to 32 bytes of memory where the resulting point is written to."]
    #[doc = "@param my_priv Pointer to 32 bytes of memory where the secret/private key is read from."]
    #[doc = "@param their_pub Pointer to 32 bytes of memory where the public point is read from."]
    pub fn EverCrypt_Curve25519_scalarmult(shared: *mut u8, my_priv: *mut u8, their_pub: *mut u8);
}
extern "C" {
    #[doc = "Execute the diffie-hellmann key exchange."]
    #[doc = ""]
    #[doc = "@param shared Pointer to 32 bytes of memory where the resulting point is written to."]
    #[doc = "@param my_priv Pointer to 32 bytes of memory where **our** secret/private key is read from."]
    #[doc = "@param their_pub Pointer to 32 bytes of memory where **their** public point is read from."]
    pub fn EverCrypt_Curve25519_ecdh(shared: *mut u8, my_priv: *mut u8, their_pub: *mut u8)
        -> bool;
}
extern "C" {
    pub fn EverCrypt_Ed25519_secret_to_public(public_key: *mut u8, private_key: *mut u8);
}
extern "C" {
    pub fn EverCrypt_Ed25519_expand_keys(expanded_keys: *mut u8, private_key: *mut u8);
}
extern "C" {
    pub fn EverCrypt_Ed25519_sign_expanded(
        signature: *mut u8,
        expanded_keys: *mut u8,
        msg_len: u32,
        msg: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_Ed25519_sign(
        signature: *mut u8,
        private_key: *mut u8,
        msg_len: u32,
        msg: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_Ed25519_verify(
        public_key: *mut u8,
        msg_len: u32,
        msg: *mut u8,
        signature: *mut u8,
    ) -> bool;
}
extern "C" {
    pub fn Hacl_SHA3_shake128_hacl(
        inputByteLen: u32,
        input: *mut u8,
        outputByteLen: u32,
        output: *mut u8,
    );
}
extern "C" {
    pub fn Hacl_SHA3_shake256_hacl(
        inputByteLen: u32,
        input: *mut u8,
        outputByteLen: u32,
        output: *mut u8,
    );
}
extern "C" {
    pub fn Hacl_SHA3_sha3_224(inputByteLen: u32, input: *mut u8, output: *mut u8);
}
extern "C" {
    pub fn Hacl_SHA3_sha3_256(inputByteLen: u32, input: *mut u8, output: *mut u8);
}
extern "C" {
    pub fn Hacl_SHA3_sha3_384(inputByteLen: u32, input: *mut u8, output: *mut u8);
}
extern "C" {
    pub fn Hacl_SHA3_sha3_512(inputByteLen: u32, input: *mut u8, output: *mut u8);
}
extern "C" {
    pub fn EverCrypt_Hash_string_of_alg(uu___: Spec_Hash_Definitions_hash_alg) -> C_String_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EverCrypt_Hash_state_s_s {
    _unused: [u8; 0],
}
pub type EverCrypt_Hash_state_s = EverCrypt_Hash_state_s_s;
extern "C" {
    pub fn EverCrypt_Hash_uu___is_MD5_s(
        uu___: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_Hash_uu___is_SHA1_s(
        uu___: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_Hash_uu___is_SHA2_224_s(
        uu___: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_Hash_uu___is_SHA2_256_s(
        uu___: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_Hash_uu___is_SHA2_384_s(
        uu___: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_Hash_uu___is_SHA2_512_s(
        uu___: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_Hash_uu___is_SHA3_256_s(
        uu___: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_Hash_uu___is_Blake2S_s(
        uu___: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_Hash_uu___is_Blake2S_128_s(
        uu___: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_Hash_uu___is_Blake2B_s(
        uu___: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_Hash_uu___is_Blake2B_256_s(
        uu___: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_Hash_alg_of_state(
        s: *mut EverCrypt_Hash_state_s,
    ) -> Spec_Hash_Definitions_hash_alg;
}
extern "C" {
    pub fn EverCrypt_Hash_create_in(
        a: Spec_Hash_Definitions_hash_alg,
    ) -> *mut EverCrypt_Hash_state_s;
}
extern "C" {
    pub fn EverCrypt_Hash_create(a: Spec_Hash_Definitions_hash_alg) -> *mut EverCrypt_Hash_state_s;
}
extern "C" {
    pub fn EverCrypt_Hash_init(s: *mut EverCrypt_Hash_state_s);
}
extern "C" {
    pub fn EverCrypt_Hash_update_multi_256(s: *mut u32, blocks: *mut u8, n: u32);
}
extern "C" {
    pub fn EverCrypt_Hash_update(s: *mut EverCrypt_Hash_state_s, prevlen: u64, block: *mut u8);
}
extern "C" {
    pub fn EverCrypt_Hash_update_multi(
        s: *mut EverCrypt_Hash_state_s,
        prevlen: u64,
        blocks: *mut u8,
        len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_Hash_update_last_256(
        s: *mut u32,
        input: u64,
        input_len: *mut u8,
        input_len1: u32,
    );
}
extern "C" {
    pub fn EverCrypt_Hash_update_last(
        s: *mut EverCrypt_Hash_state_s,
        prev_len: u64,
        last: *mut u8,
        last_len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_Hash_finish(s: *mut EverCrypt_Hash_state_s, dst: *mut u8);
}
extern "C" {
    pub fn EverCrypt_Hash_free(s: *mut EverCrypt_Hash_state_s);
}
extern "C" {
    pub fn EverCrypt_Hash_copy(
        s_src: *mut EverCrypt_Hash_state_s,
        s_dst: *mut EverCrypt_Hash_state_s,
    );
}
extern "C" {
    pub fn EverCrypt_Hash_hash_256(input: *mut u8, input_len: u32, dst: *mut u8);
}
extern "C" {
    pub fn EverCrypt_Hash_hash_224(input: *mut u8, input_len: u32, dst: *mut u8);
}
extern "C" {
    pub fn EverCrypt_Hash_hash(
        a: Spec_Hash_Definitions_hash_alg,
        dst: *mut u8,
        input: *mut u8,
        len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_hash_len(a: Spec_Hash_Definitions_hash_alg) -> u32;
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_block_len(a: Spec_Hash_Definitions_hash_alg) -> u32;
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_create_in(
        a: Spec_Hash_Definitions_hash_alg,
    ) -> *mut Hacl_Streaming_Functor_state_s___EverCrypt_Hash_state_s____;
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_init(
        s: *mut Hacl_Streaming_Functor_state_s___EverCrypt_Hash_state_s____,
    );
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_update(
        s: *mut Hacl_Streaming_Functor_state_s___EverCrypt_Hash_state_s____,
        data: *mut u8,
        len: u32,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_finish_md5(
        p: *mut Hacl_Streaming_Functor_state_s___EverCrypt_Hash_state_s____,
        dst: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_finish_sha1(
        p: *mut Hacl_Streaming_Functor_state_s___EverCrypt_Hash_state_s____,
        dst: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_finish_sha224(
        p: *mut Hacl_Streaming_Functor_state_s___EverCrypt_Hash_state_s____,
        dst: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_finish_sha256(
        p: *mut Hacl_Streaming_Functor_state_s___EverCrypt_Hash_state_s____,
        dst: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_finish_sha3_256(
        p: *mut Hacl_Streaming_Functor_state_s___EverCrypt_Hash_state_s____,
        dst: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_finish_sha384(
        p: *mut Hacl_Streaming_Functor_state_s___EverCrypt_Hash_state_s____,
        dst: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_finish_sha512(
        p: *mut Hacl_Streaming_Functor_state_s___EverCrypt_Hash_state_s____,
        dst: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_finish_blake2s(
        p: *mut Hacl_Streaming_Functor_state_s___EverCrypt_Hash_state_s____,
        dst: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_finish_blake2b(
        p: *mut Hacl_Streaming_Functor_state_s___EverCrypt_Hash_state_s____,
        dst: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_alg_of_state(
        s: *mut Hacl_Streaming_Functor_state_s___EverCrypt_Hash_state_s____,
    ) -> Spec_Hash_Definitions_hash_alg;
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_finish(
        s: *mut Hacl_Streaming_Functor_state_s___EverCrypt_Hash_state_s____,
        dst: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_free(
        s: *mut Hacl_Streaming_Functor_state_s___EverCrypt_Hash_state_s____,
    );
}
extern "C" {
    pub fn EverCrypt_HMAC_compute_sha1(
        dst: *mut u8,
        key: *mut u8,
        key_len: u32,
        data: *mut u8,
        data_len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HMAC_compute_sha2_256(
        dst: *mut u8,
        key: *mut u8,
        key_len: u32,
        data: *mut u8,
        data_len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HMAC_compute_sha2_384(
        dst: *mut u8,
        key: *mut u8,
        key_len: u32,
        data: *mut u8,
        data_len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HMAC_compute_sha2_512(
        dst: *mut u8,
        key: *mut u8,
        key_len: u32,
        data: *mut u8,
        data_len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HMAC_compute_blake2s(
        dst: *mut u8,
        key: *mut u8,
        key_len: u32,
        data: *mut u8,
        data_len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HMAC_compute_blake2b(
        dst: *mut u8,
        key: *mut u8,
        key_len: u32,
        data: *mut u8,
        data_len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HMAC_is_supported_alg(uu___: Spec_Hash_Definitions_hash_alg) -> bool;
}
extern "C" {
    pub fn EverCrypt_HMAC_compute(
        a: Spec_Hash_Definitions_hash_alg,
        mac: *mut u8,
        key: *mut u8,
        keylen: u32,
        data: *mut u8,
        datalen: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_expand_sha1(
        okm: *mut u8,
        prk: *mut u8,
        prklen: u32,
        info: *mut u8,
        infolen: u32,
        len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_extract_sha1(
        prk: *mut u8,
        salt: *mut u8,
        saltlen: u32,
        ikm: *mut u8,
        ikmlen: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_expand_sha2_256(
        okm: *mut u8,
        prk: *mut u8,
        prklen: u32,
        info: *mut u8,
        infolen: u32,
        len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_extract_sha2_256(
        prk: *mut u8,
        salt: *mut u8,
        saltlen: u32,
        ikm: *mut u8,
        ikmlen: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_expand_sha2_384(
        okm: *mut u8,
        prk: *mut u8,
        prklen: u32,
        info: *mut u8,
        infolen: u32,
        len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_extract_sha2_384(
        prk: *mut u8,
        salt: *mut u8,
        saltlen: u32,
        ikm: *mut u8,
        ikmlen: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_expand_sha2_512(
        okm: *mut u8,
        prk: *mut u8,
        prklen: u32,
        info: *mut u8,
        infolen: u32,
        len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_extract_sha2_512(
        prk: *mut u8,
        salt: *mut u8,
        saltlen: u32,
        ikm: *mut u8,
        ikmlen: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_expand_blake2s(
        okm: *mut u8,
        prk: *mut u8,
        prklen: u32,
        info: *mut u8,
        infolen: u32,
        len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_extract_blake2s(
        prk: *mut u8,
        salt: *mut u8,
        saltlen: u32,
        ikm: *mut u8,
        ikmlen: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_expand_blake2b(
        okm: *mut u8,
        prk: *mut u8,
        prklen: u32,
        info: *mut u8,
        infolen: u32,
        len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_extract_blake2b(
        prk: *mut u8,
        salt: *mut u8,
        saltlen: u32,
        ikm: *mut u8,
        ikmlen: u32,
    );
}
extern "C" {
    #[doc = "Expand pseudorandom key to desired length."]
    #[doc = ""]
    #[doc = "@param a Hash function to use. Usually, the same as used in `EverCrypt_HKDF_extract`."]
    #[doc = "@param okm Pointer to `len` bytes of memory where output keying material is written to."]
    #[doc = "@param prk Pointer to at least `HashLen` bytes of memory where pseudorandom key is read from. Usually, this points to the output from the extract step."]
    #[doc = "@param prklen Length of pseudorandom key."]
    #[doc = "@param info Pointer to `infolen` bytes of memory where context and application specific information is read from."]
    #[doc = "@param infolen Length of context and application specific information. Can be 0."]
    #[doc = "@param len Length of output keying material."]
    pub fn EverCrypt_HKDF_expand(
        a: Spec_Hash_Definitions_hash_alg,
        okm: *mut u8,
        prk: *mut u8,
        prklen: u32,
        info: *mut u8,
        infolen: u32,
        len: u32,
    );
}
extern "C" {
    #[doc = "Extract a fixed-length pseudorandom key from input keying material."]
    #[doc = ""]
    #[doc = "@param a Hash function to use. The allowed values are:"]
    #[doc = " `Spec_Hash_Definitions_Blake2B` (`HashLen` = 64),"]
    #[doc = " `Spec_Hash_Definitions_Blake2S` (`HashLen` = 32),"]
    #[doc = " `Spec_Hash_Definitions_SHA2_256` (`HashLen` = 32),"]
    #[doc = " `Spec_Hash_Definitions_SHA2_384` (`HashLen` = 48),"]
    #[doc = " `Spec_Hash_Definitions_SHA2_512` (`HashLen` = 64), and"]
    #[doc = " `Spec_Hash_Definitions_SHA1` (`HashLen` = 20)."]
    #[doc = "@param prk Pointer to `HashLen` bytes of memory where pseudorandom key is written to."]
    #[doc = "`HashLen` depends on the used algorithm `a`. See above."]
    #[doc = "@param salt Pointer to `saltlen` bytes of memory where salt value is read from."]
    #[doc = "@param saltlen Length of salt value."]
    #[doc = "@param ikm Pointer to `ikmlen` bytes of memory where input keying material is read from."]
    #[doc = "@param ikmlen Length of input keying material."]
    pub fn EverCrypt_HKDF_extract(
        a: Spec_Hash_Definitions_hash_alg,
        prk: *mut u8,
        salt: *mut u8,
        saltlen: u32,
        ikm: *mut u8,
        ikmlen: u32,
    );
}
extern "C" {
    #[doc = "Hash the message with SHA2-256, then sign the resulting digest with the P256 signature function."]
    #[doc = ""]
    #[doc = "Input: result buffer: uint8[64],"]
    #[doc = "m buffer: uint8 [mLen],"]
    #[doc = "priv(ate)Key: uint8[32],"]
    #[doc = "k (nonce): uint32[32]."]
    #[doc = ""]
    #[doc = "Output: bool, where True stands for the correct signature generation. False value means that an error has occurred."]
    #[doc = ""]
    #[doc = "The private key and the nonce are expected to be more than 0 and less than the curve order."]
    pub fn Hacl_P256_ecdsa_sign_p256_sha2(
        result: *mut u8,
        mLen: u32,
        m: *mut u8,
        privKey: *mut u8,
        k: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "Hash the message with SHA2-384, then sign the resulting digest with the P256 signature function."]
    #[doc = ""]
    #[doc = "Input: result buffer: uint8[64],"]
    #[doc = "m buffer: uint8 [mLen],"]
    #[doc = "priv(ate)Key: uint8[32],"]
    #[doc = "k (nonce): uint32[32]."]
    #[doc = ""]
    #[doc = "Output: bool, where True stands for the correct signature generation. False value means that an error has occurred."]
    #[doc = ""]
    #[doc = "The private key and the nonce are expected to be more than 0 and less than the curve order."]
    pub fn Hacl_P256_ecdsa_sign_p256_sha384(
        result: *mut u8,
        mLen: u32,
        m: *mut u8,
        privKey: *mut u8,
        k: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "Hash the message with SHA2-512, then sign the resulting digest with the P256 signature function."]
    #[doc = ""]
    #[doc = "Input: result buffer: uint8[64],"]
    #[doc = "m buffer: uint8 [mLen],"]
    #[doc = "priv(ate)Key: uint8[32],"]
    #[doc = "k (nonce): uint32[32]."]
    #[doc = ""]
    #[doc = "Output: bool, where True stands for the correct signature generation. False value means that an error has occurred."]
    #[doc = ""]
    #[doc = "The private key and the nonce are expected to be more than 0 and less than the curve order."]
    pub fn Hacl_P256_ecdsa_sign_p256_sha512(
        result: *mut u8,
        mLen: u32,
        m: *mut u8,
        privKey: *mut u8,
        k: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "P256 signature WITHOUT hashing first."]
    #[doc = ""]
    #[doc = "This function is intended to receive a hash of the input. For convenience, we"]
    #[doc = "recommend using one of the hash-and-sign combined functions above."]
    #[doc = ""]
    #[doc = "The argument `m` MUST be at least 32 bytes (i.e. `mLen >= 32`)."]
    #[doc = ""]
    #[doc = "NOTE: The equivalent functions in OpenSSL and Fiat-Crypto both accept inputs"]
    #[doc = "smaller than 32 bytes. These libraries left-pad the input with enough zeroes to"]
    #[doc = "reach the minimum 32 byte size. Clients who need behavior identical to OpenSSL"]
    #[doc = "need to perform the left-padding themselves."]
    #[doc = ""]
    #[doc = "Input: result buffer: uint8[64],"]
    #[doc = "m buffer: uint8 [mLen],"]
    #[doc = "priv(ate)Key: uint8[32],"]
    #[doc = "k (nonce): uint32[32]."]
    #[doc = ""]
    #[doc = "Output: bool, where True stands for the correct signature generation. False value means that an error has occurred."]
    #[doc = ""]
    #[doc = "The private key and the nonce are expected to be more than 0 and less than the curve order."]
    #[doc = ""]
    #[doc = "The message m is expected to be hashed by a strong hash function, the lenght of the message is expected to be 32 bytes and more."]
    pub fn Hacl_P256_ecdsa_sign_p256_without_hash(
        result: *mut u8,
        mLen: u32,
        m: *mut u8,
        privKey: *mut u8,
        k: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "The input of the function is considered to be public,"]
    #[doc = "thus this code is not secret independent with respect to the operations done over the input."]
    #[doc = ""]
    #[doc = "Input: m buffer: uint8 [mLen],"]
    #[doc = "pub(lic)Key: uint8[64],"]
    #[doc = "r: uint8[32],"]
    #[doc = "s: uint8[32]."]
    #[doc = ""]
    #[doc = "Output: bool, where true stands for the correct signature verification."]
    pub fn Hacl_P256_ecdsa_verif_p256_sha2(
        mLen: u32,
        m: *mut u8,
        pubKey: *mut u8,
        r: *mut u8,
        s: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "The input of the function is considered to be public,"]
    #[doc = "thus this code is not secret independent with respect to the operations done over the input."]
    #[doc = ""]
    #[doc = "Input: m buffer: uint8 [mLen],"]
    #[doc = "pub(lic)Key: uint8[64],"]
    #[doc = "r: uint8[32],"]
    #[doc = "s: uint8[32]."]
    #[doc = ""]
    #[doc = "Output: bool, where true stands for the correct signature verification."]
    pub fn Hacl_P256_ecdsa_verif_p256_sha384(
        mLen: u32,
        m: *mut u8,
        pubKey: *mut u8,
        r: *mut u8,
        s: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "The input of the function is considered to be public,"]
    #[doc = "thus this code is not secret independent with respect to the operations done over the input."]
    #[doc = ""]
    #[doc = "Input: m buffer: uint8 [mLen],"]
    #[doc = "pub(lic)Key: uint8[64],"]
    #[doc = "r: uint8[32],"]
    #[doc = "s: uint8[32]."]
    #[doc = ""]
    #[doc = "Output: bool, where true stands for the correct signature verification."]
    pub fn Hacl_P256_ecdsa_verif_p256_sha512(
        mLen: u32,
        m: *mut u8,
        pubKey: *mut u8,
        r: *mut u8,
        s: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "The input of the function is considered to be public,"]
    #[doc = "thus this code is not secret independent with respect to the operations done over the input."]
    #[doc = ""]
    #[doc = "Input: m buffer: uint8 [mLen],"]
    #[doc = "pub(lic)Key: uint8[64],"]
    #[doc = "r: uint8[32],"]
    #[doc = "s: uint8[32]."]
    #[doc = ""]
    #[doc = "Output: bool, where true stands for the correct signature verification."]
    #[doc = ""]
    #[doc = "The message m is expected to be hashed by a strong hash function, the lenght of the message is expected to be 32 bytes and more."]
    pub fn Hacl_P256_ecdsa_verif_without_hash(
        mLen: u32,
        m: *mut u8,
        pubKey: *mut u8,
        r: *mut u8,
        s: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "Validate a public key."]
    #[doc = ""]
    #[doc = "Input: pub(lic)Key: uint8[64]."]
    #[doc = "Output: bool, where 0 stands for the public key to be correct with respect to SP 800-56A:"]
    #[doc = "• Verify that the public key is not the “point at infinity”, represented as O."]
    #[doc = "• Verify that the affine x and y coordinates of the point represented by the public key are in the range [0, p – 1] where p is the prime defining the finite field."]
    #[doc = "• Verify that y^2 = x^3 + ax + b where a and b are the coefficients of the curve equation."]
    #[doc = "The last extract is taken from : https://neilmadden.blog/2017/05/17/so-how-do-you-validate-nist-ecdh-public-keys/"]
    pub fn Hacl_P256_validate_public_key(pubKey: *mut u8) -> bool;
}
extern "C" {
    #[doc = "Validate a private key, e.g. prior to signing."]
    #[doc = ""]
    #[doc = "Input: scalar: uint8[32]."]
    #[doc = ""]
    #[doc = "Output: bool, where true stands for the scalar to be more than 0 and less than order."]
    pub fn Hacl_P256_validate_private_key(x: *mut u8) -> bool;
}
extern "C" {
    #[doc = "Convert 65-byte uncompressed to raw."]
    #[doc = ""]
    #[doc = "The function errors out if the first byte is incorrect, or if the resulting point is invalid."]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "Input: a point in not compressed form (uint8[65]),"]
    #[doc = "result: uint8[64] (internal point representation)."]
    #[doc = ""]
    #[doc = "Output: bool, where true stands for the correct decompression."]
    pub fn Hacl_P256_uncompressed_to_raw(b: *mut u8, result: *mut u8) -> bool;
}
extern "C" {
    #[doc = "Convert 33-byte compressed to raw."]
    #[doc = ""]
    #[doc = "The function errors out if the first byte is incorrect, or if the resulting point is invalid."]
    #[doc = ""]
    #[doc = "Input: a point in compressed form (uint8[33]),"]
    #[doc = "result: uint8[64] (internal point representation)."]
    #[doc = ""]
    #[doc = "Output: bool, where true stands for the correct decompression."]
    pub fn Hacl_P256_compressed_to_raw(b: *mut u8, result: *mut u8) -> bool;
}
extern "C" {
    #[doc = "Convert raw to 65-byte uncompressed."]
    #[doc = ""]
    #[doc = "This function effectively prepends a 0x04 byte."]
    #[doc = ""]
    #[doc = "Input: a point buffer (internal representation: uint8[64]),"]
    #[doc = "result: a point in not compressed form (uint8[65])."]
    pub fn Hacl_P256_raw_to_uncompressed(b: *mut u8, result: *mut u8);
}
extern "C" {
    #[doc = "Convert raw to 33-byte compressed."]
    #[doc = ""]
    #[doc = "Input: `b`, the pointer buffer in internal representation, of type `uint8[64]`"]
    #[doc = "Output: `result`, a point in compressed form, of type `uint8[33]`"]
    pub fn Hacl_P256_raw_to_compressed(b: *mut u8, result: *mut u8);
}
extern "C" {
    #[doc = "Convert a private key into a raw public key."]
    #[doc = ""]
    #[doc = "This function performs no key validation."]
    #[doc = ""]
    #[doc = "Input: `scalar`, the private key, of type `uint8[32]`."]
    #[doc = "Output: `result`, the public key, of type `uint8[64]`."]
    #[doc = "Returns:"]
    #[doc = "- `true`, for success, meaning the public key is not a point at infinity"]
    #[doc = "- `false`, otherwise."]
    #[doc = ""]
    #[doc = "`scalar` and `result` MUST NOT overlap."]
    pub fn Hacl_P256_dh_initiator(result: *mut u8, scalar: *mut u8) -> bool;
}
extern "C" {
    #[doc = "ECDH key agreement."]
    #[doc = ""]
    #[doc = "This function takes a 32-byte secret key, another party's 64-byte raw public"]
    #[doc = "key, and computeds the 64-byte ECDH shared key."]
    #[doc = ""]
    #[doc = "This function ONLY validates the public key."]
    #[doc = ""]
    #[doc = "The pub(lic)_key input of the function is considered to be public,"]
    #[doc = "thus this code is not secret independent with respect to the operations done over this variable."]
    #[doc = ""]
    #[doc = "Input: result: uint8[64],"]
    #[doc = "pub(lic)Key: uint8[64],"]
    #[doc = "scalar: uint8[32]."]
    #[doc = ""]
    #[doc = "Output: bool, where True stands for the correct key generation. False value means that an error has occurred (possibly the provided public key was incorrect or the result represents point at infinity)."]
    pub fn Hacl_P256_dh_responder(result: *mut u8, pubKey: *mut u8, scalar: *mut u8) -> bool;
}
extern "C" {
    #[doc = "Sign a message `msg` and write the signature to `sgnt`."]
    #[doc = ""]
    #[doc = "@param a Hash algorithm to use. Allowed values for `a` are ..."]
    #[doc = " Spec_Hash_Definitions_SHA2_256,"]
    #[doc = " Spec_Hash_Definitions_SHA2_384, and"]
    #[doc = " Spec_Hash_Definitions_SHA2_512."]
    #[doc = "@param modBits Count of bits in the modulus (`n`)."]
    #[doc = "@param eBits Count of bits in `e` value."]
    #[doc = "@param dBits Count of bits in `d` value."]
    #[doc = "@param skey Pointer to secret key created by `Hacl_RSAPSS_new_rsapss_load_skey`."]
    #[doc = "@param saltLen Length of salt."]
    #[doc = "@param salt Pointer to `saltLen` bytes where the salt is read from."]
    #[doc = "@param msgLen Length of message."]
    #[doc = "@param msg Pointer to `msgLen` bytes where the message is read from."]
    #[doc = "@param sgnt Pointer to `ceil(modBits / 8)` bytes where the signature is written to."]
    #[doc = ""]
    #[doc = "@return Returns true if and only if signing was successful."]
    pub fn Hacl_RSAPSS_rsapss_sign(
        a: Spec_Hash_Definitions_hash_alg,
        modBits: u32,
        eBits: u32,
        dBits: u32,
        skey: *mut u64,
        saltLen: u32,
        salt: *mut u8,
        msgLen: u32,
        msg: *mut u8,
        sgnt: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "Verify the signature `sgnt` of a message `msg`."]
    #[doc = ""]
    #[doc = "@param a Hash algorithm to use."]
    #[doc = "@param modBits Count of bits in the modulus (`n`)."]
    #[doc = "@param eBits Count of bits in `e` value."]
    #[doc = "@param pkey Pointer to public key created by `Hacl_RSAPSS_new_rsapss_load_pkey`."]
    #[doc = "@param saltLen Length of salt."]
    #[doc = "@param sgntLen Length of signature."]
    #[doc = "@param sgnt Pointer to `sgntLen` bytes where the signature is read from."]
    #[doc = "@param msgLen Length of message."]
    #[doc = "@param msg Pointer to `msgLen` bytes where the message is read from."]
    #[doc = ""]
    #[doc = "@return Returns true if and only if the signature is valid."]
    pub fn Hacl_RSAPSS_rsapss_verify(
        a: Spec_Hash_Definitions_hash_alg,
        modBits: u32,
        eBits: u32,
        pkey: *mut u64,
        saltLen: u32,
        sgntLen: u32,
        sgnt: *mut u8,
        msgLen: u32,
        msg: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "Load a public key from key parts."]
    #[doc = ""]
    #[doc = "@param modBits Count of bits in modulus (`n`)."]
    #[doc = "@param eBits Count of bits in `e` value."]
    #[doc = "@param nb Pointer to `ceil(modBits / 8)` bytes where the modulus (`n`) is read from."]
    #[doc = "@param eb Pointer to `ceil(modBits / 8)` bytes where the `e` value is read from."]
    #[doc = ""]
    #[doc = "@return Returns an allocated public key. Note: caller must take care to `free()` the created key."]
    pub fn Hacl_RSAPSS_new_rsapss_load_pkey(
        modBits: u32,
        eBits: u32,
        nb: *mut u8,
        eb: *mut u8,
    ) -> *mut u64;
}
extern "C" {
    #[doc = "Load a secret key from key parts."]
    #[doc = ""]
    #[doc = "@param modBits Count of bits in modulus (`n`)."]
    #[doc = "@param eBits Count of bits in `e` value."]
    #[doc = "@param dBits Count of bits in `d` value."]
    #[doc = "@param nb Pointer to `ceil(modBits / 8)` bytes where the modulus (`n`) is read from."]
    #[doc = "@param eb Pointer to `ceil(modBits / 8)` bytes where the `e` value is read from."]
    #[doc = "@param db Pointer to `ceil(modBits / 8)` bytes where the `d` value is read from."]
    #[doc = ""]
    #[doc = "@return Returns an allocated secret key. Note: caller must take care to `free()` the created key."]
    pub fn Hacl_RSAPSS_new_rsapss_load_skey(
        modBits: u32,
        eBits: u32,
        dBits: u32,
        nb: *mut u8,
        eb: *mut u8,
        db: *mut u8,
    ) -> *mut u64;
}
extern "C" {
    #[doc = "Sign a message `msg` and write the signature to `sgnt`."]
    #[doc = ""]
    #[doc = "@param a Hash algorithm to use."]
    #[doc = "@param modBits Count of bits in the modulus (`n`)."]
    #[doc = "@param eBits Count of bits in `e` value."]
    #[doc = "@param dBits Count of bits in `d` value."]
    #[doc = "@param nb Pointer to `ceil(modBits / 8)` bytes where the modulus (`n`) is read from."]
    #[doc = "@param eb Pointer to `ceil(modBits / 8)` bytes where the `e` value is read from."]
    #[doc = "@param db Pointer to `ceil(modBits / 8)` bytes where the `d` value is read from."]
    #[doc = "@param saltLen Length of salt."]
    #[doc = "@param salt Pointer to `saltLen` bytes where the salt is read from."]
    #[doc = "@param msgLen Length of message."]
    #[doc = "@param msg Pointer to `msgLen` bytes where the message is read from."]
    #[doc = "@param sgnt Pointer to `ceil(modBits / 8)` bytes where the signature is written to."]
    #[doc = ""]
    #[doc = "@return Returns true if and only if signing was successful."]
    pub fn Hacl_RSAPSS_rsapss_skey_sign(
        a: Spec_Hash_Definitions_hash_alg,
        modBits: u32,
        eBits: u32,
        dBits: u32,
        nb: *mut u8,
        eb: *mut u8,
        db: *mut u8,
        saltLen: u32,
        salt: *mut u8,
        msgLen: u32,
        msg: *mut u8,
        sgnt: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "Verify the signature `sgnt` of a message `msg`."]
    #[doc = ""]
    #[doc = "@param a Hash algorithm to use."]
    #[doc = "@param modBits Count of bits in the modulus (`n`)."]
    #[doc = "@param eBits Count of bits in `e` value."]
    #[doc = "@param nb Pointer to `ceil(modBits / 8)` bytes where the modulus (`n`) is read from."]
    #[doc = "@param eb Pointer to `ceil(modBits / 8)` bytes where the `e` value is read from."]
    #[doc = "@param saltLen Length of salt."]
    #[doc = "@param sgntLen Length of signature."]
    #[doc = "@param sgnt Pointer to `sgntLen` bytes where the signature is read from."]
    #[doc = "@param msgLen Length of message."]
    #[doc = "@param msg Pointer to `msgLen` bytes where the message is read from."]
    #[doc = ""]
    #[doc = "@return Returns true if and only if the signature is valid."]
    pub fn Hacl_RSAPSS_rsapss_pkey_verify(
        a: Spec_Hash_Definitions_hash_alg,
        modBits: u32,
        eBits: u32,
        nb: *mut u8,
        eb: *mut u8,
        saltLen: u32,
        sgntLen: u32,
        sgnt: *mut u8,
        msgLen: u32,
        msg: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "The mask generation function defined in the Public Key Cryptography Standard #1"]
    #[doc = "(https://www.ietf.org/rfc/rfc2437.txt Section 10.2.1)"]
    pub fn Hacl_RSAPSS_mgf_hash(
        a: Spec_Hash_Definitions_hash_alg,
        len: u32,
        mgfseed: *mut u8,
        maskLen: u32,
        res: *mut u8,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Hacl_Bignum_MontArithmetic_bn_mont_ctx_u64_s {
    pub len: u32,
    pub n: *mut u64,
    pub mu: u64,
    pub r2: *mut u64,
}
pub type Hacl_Bignum_MontArithmetic_bn_mont_ctx_u64 = Hacl_Bignum_MontArithmetic_bn_mont_ctx_u64_s;
extern "C" {
    #[doc = "Write `a + b mod 2^4096` in `res`."]
    #[doc = ""]
    #[doc = "This functions returns the carry."]
    #[doc = ""]
    #[doc = "The arguments a, b and res are meant to be 4096-bit bignums, i.e. uint64_t[64]"]
    pub fn Hacl_Bignum4096_add(a: *mut u64, b: *mut u64, res: *mut u64) -> u64;
}
extern "C" {
    #[doc = "Write `a - b mod 2^4096` in `res`."]
    #[doc = ""]
    #[doc = "This functions returns the carry."]
    #[doc = ""]
    #[doc = "The arguments a, b and res are meant to be 4096-bit bignums, i.e. uint64_t[64]"]
    pub fn Hacl_Bignum4096_sub(a: *mut u64, b: *mut u64, res: *mut u64) -> u64;
}
extern "C" {
    #[doc = "Write `(a + b) mod n` in `res`."]
    #[doc = ""]
    #[doc = "The arguments a, b, n and the outparam res are meant to be 4096-bit bignums, i.e. uint64_t[64]."]
    #[doc = ""]
    #[doc = "Before calling this function, the caller will need to ensure that the following"]
    #[doc = "preconditions are observed."]
    #[doc = "• a < n"]
    #[doc = "• b < n"]
    pub fn Hacl_Bignum4096_add_mod(n: *mut u64, a: *mut u64, b: *mut u64, res: *mut u64);
}
extern "C" {
    #[doc = "Write `(a - b) mod n` in `res`."]
    #[doc = ""]
    #[doc = "The arguments a, b, n and the outparam res are meant to be 4096-bit bignums, i.e. uint64_t[64]."]
    #[doc = ""]
    #[doc = "Before calling this function, the caller will need to ensure that the following"]
    #[doc = "preconditions are observed."]
    #[doc = "• a < n"]
    #[doc = "• b < n"]
    pub fn Hacl_Bignum4096_sub_mod(n: *mut u64, a: *mut u64, b: *mut u64, res: *mut u64);
}
extern "C" {
    #[doc = "Write `a * b` in `res`."]
    #[doc = ""]
    #[doc = "The arguments a and b are meant to be 4096-bit bignums, i.e. uint64_t[64]."]
    #[doc = "The outparam res is meant to be a 8192-bit bignum, i.e. uint64_t[128]."]
    pub fn Hacl_Bignum4096_mul(a: *mut u64, b: *mut u64, res: *mut u64);
}
extern "C" {
    #[doc = "Write `a * a` in `res`."]
    #[doc = ""]
    #[doc = "The argument a is meant to be a 4096-bit bignum, i.e. uint64_t[64]."]
    #[doc = "The outparam res is meant to be a 8192-bit bignum, i.e. uint64_t[128]."]
    pub fn Hacl_Bignum4096_sqr(a: *mut u64, res: *mut u64);
}
extern "C" {
    #[doc = "Write `a mod n` in `res`."]
    #[doc = ""]
    #[doc = "The argument a is meant to be a 8192-bit bignum, i.e. uint64_t[128]."]
    #[doc = "The argument n and the outparam res are meant to be 4096-bit bignums, i.e. uint64_t[64]."]
    #[doc = ""]
    #[doc = "The function returns false if any of the following preconditions are violated,"]
    #[doc = "true otherwise."]
    #[doc = "• 1 < n"]
    #[doc = "• n % 2 = 1"]
    pub fn Hacl_Bignum4096_mod(n: *mut u64, a: *mut u64, res: *mut u64) -> bool;
}
extern "C" {
    #[doc = "Write `a ^ b mod n` in `res`."]
    #[doc = ""]
    #[doc = "The arguments a, n and the outparam res are meant to be 4096-bit bignums, i.e. uint64_t[64]."]
    #[doc = ""]
    #[doc = "The argument b is a bignum of any size, and bBits is an upper bound on the"]
    #[doc = "number of significant bits of b. A tighter bound results in faster execution"]
    #[doc = "time. When in doubt, the number of bits for the bignum size is always a safe"]
    #[doc = "default, e.g. if b is a 4096-bit bignum, bBits should be 4096."]
    #[doc = ""]
    #[doc = "The function is *NOT* constant-time on the argument b. See the"]
    #[doc = "mod_exp_consttime_* functions for constant-time variants."]
    #[doc = ""]
    #[doc = "The function returns false if any of the following preconditions are violated,"]
    #[doc = "true otherwise."]
    #[doc = "• n % 2 = 1"]
    #[doc = "• 1 < n"]
    #[doc = "• b < pow2 bBits"]
    #[doc = "• a < n"]
    pub fn Hacl_Bignum4096_mod_exp_vartime(
        n: *mut u64,
        a: *mut u64,
        bBits: u32,
        b: *mut u64,
        res: *mut u64,
    ) -> bool;
}
extern "C" {
    #[doc = "Write `a ^ b mod n` in `res`."]
    #[doc = ""]
    #[doc = "The arguments a, n and the outparam res are meant to be 4096-bit bignums, i.e. uint64_t[64]."]
    #[doc = ""]
    #[doc = "The argument b is a bignum of any size, and bBits is an upper bound on the"]
    #[doc = "number of significant bits of b. A tighter bound results in faster execution"]
    #[doc = "time. When in doubt, the number of bits for the bignum size is always a safe"]
    #[doc = "default, e.g. if b is a 4096-bit bignum, bBits should be 4096."]
    #[doc = ""]
    #[doc = "This function is constant-time over its argument b, at the cost of a slower"]
    #[doc = "execution time than mod_exp_vartime."]
    #[doc = ""]
    #[doc = "The function returns false if any of the following preconditions are violated,"]
    #[doc = "true otherwise."]
    #[doc = "• n % 2 = 1"]
    #[doc = "• 1 < n"]
    #[doc = "• b < pow2 bBits"]
    #[doc = "• a < n"]
    pub fn Hacl_Bignum4096_mod_exp_consttime(
        n: *mut u64,
        a: *mut u64,
        bBits: u32,
        b: *mut u64,
        res: *mut u64,
    ) -> bool;
}
extern "C" {
    #[doc = "Write `a ^ (-1) mod n` in `res`."]
    #[doc = ""]
    #[doc = "The arguments a, n and the outparam res are meant to be 4096-bit bignums, i.e. uint64_t[64]."]
    #[doc = ""]
    #[doc = "Before calling this function, the caller will need to ensure that the following"]
    #[doc = "preconditions are observed."]
    #[doc = "• n is a prime"]
    #[doc = ""]
    #[doc = "The function returns false if any of the following preconditions are violated, true otherwise."]
    #[doc = "• n % 2 = 1"]
    #[doc = "• 1 < n"]
    #[doc = "• 0 < a"]
    #[doc = "• a < n"]
    pub fn Hacl_Bignum4096_mod_inv_prime_vartime(n: *mut u64, a: *mut u64, res: *mut u64) -> bool;
}
extern "C" {
    #[doc = "Heap-allocate and initialize a montgomery context."]
    #[doc = ""]
    #[doc = "The argument n is meant to be a 4096-bit bignum, i.e. uint64_t[64]."]
    #[doc = ""]
    #[doc = "Before calling this function, the caller will need to ensure that the following"]
    #[doc = "preconditions are observed."]
    #[doc = "• n % 2 = 1"]
    #[doc = "• 1 < n"]
    #[doc = ""]
    #[doc = "The caller will need to call Hacl_Bignum4096_mont_ctx_free on the return value"]
    #[doc = "to avoid memory leaks."]
    pub fn Hacl_Bignum4096_mont_ctx_init(
        n: *mut u64,
    ) -> *mut Hacl_Bignum_MontArithmetic_bn_mont_ctx_u64;
}
extern "C" {
    #[doc = "Deallocate the memory previously allocated by Hacl_Bignum4096_mont_ctx_init."]
    #[doc = ""]
    #[doc = "The argument k is a montgomery context obtained through Hacl_Bignum4096_mont_ctx_init."]
    pub fn Hacl_Bignum4096_mont_ctx_free(k: *mut Hacl_Bignum_MontArithmetic_bn_mont_ctx_u64);
}
extern "C" {
    #[doc = "Write `a mod n` in `res`."]
    #[doc = ""]
    #[doc = "The argument a is meant to be a 8192-bit bignum, i.e. uint64_t[128]."]
    #[doc = "The outparam res is meant to be a 4096-bit bignum, i.e. uint64_t[64]."]
    #[doc = "The argument k is a montgomery context obtained through Hacl_Bignum4096_mont_ctx_init."]
    pub fn Hacl_Bignum4096_mod_precomp(
        k: *mut Hacl_Bignum_MontArithmetic_bn_mont_ctx_u64,
        a: *mut u64,
        res: *mut u64,
    );
}
extern "C" {
    #[doc = "Write `a ^ b mod n` in `res`."]
    #[doc = ""]
    #[doc = "The arguments a and the outparam res are meant to be 4096-bit bignums, i.e. uint64_t[64]."]
    #[doc = "The argument k is a montgomery context obtained through Hacl_Bignum4096_mont_ctx_init."]
    #[doc = ""]
    #[doc = "The argument b is a bignum of any size, and bBits is an upper bound on the"]
    #[doc = "number of significant bits of b. A tighter bound results in faster execution"]
    #[doc = "time. When in doubt, the number of bits for the bignum size is always a safe"]
    #[doc = "default, e.g. if b is a 4096-bit bignum, bBits should be 4096."]
    #[doc = ""]
    #[doc = "The function is *NOT* constant-time on the argument b. See the"]
    #[doc = "mod_exp_consttime_* functions for constant-time variants."]
    #[doc = ""]
    #[doc = "Before calling this function, the caller will need to ensure that the following"]
    #[doc = "preconditions are observed."]
    #[doc = "• b < pow2 bBits"]
    #[doc = "• a < n"]
    pub fn Hacl_Bignum4096_mod_exp_vartime_precomp(
        k: *mut Hacl_Bignum_MontArithmetic_bn_mont_ctx_u64,
        a: *mut u64,
        bBits: u32,
        b: *mut u64,
        res: *mut u64,
    );
}
extern "C" {
    #[doc = "Write `a ^ b mod n` in `res`."]
    #[doc = ""]
    #[doc = "The arguments a and the outparam res are meant to be 4096-bit bignums, i.e. uint64_t[64]."]
    #[doc = "The argument k is a montgomery context obtained through Hacl_Bignum4096_mont_ctx_init."]
    #[doc = ""]
    #[doc = "The argument b is a bignum of any size, and bBits is an upper bound on the"]
    #[doc = "number of significant bits of b. A tighter bound results in faster execution"]
    #[doc = "time. When in doubt, the number of bits for the bignum size is always a safe"]
    #[doc = "default, e.g. if b is a 4096-bit bignum, bBits should be 4096."]
    #[doc = ""]
    #[doc = "This function is constant-time over its argument b, at the cost of a slower"]
    #[doc = "execution time than mod_exp_vartime_*."]
    #[doc = ""]
    #[doc = "Before calling this function, the caller will need to ensure that the following"]
    #[doc = "preconditions are observed."]
    #[doc = "• b < pow2 bBits"]
    #[doc = "• a < n"]
    pub fn Hacl_Bignum4096_mod_exp_consttime_precomp(
        k: *mut Hacl_Bignum_MontArithmetic_bn_mont_ctx_u64,
        a: *mut u64,
        bBits: u32,
        b: *mut u64,
        res: *mut u64,
    );
}
extern "C" {
    #[doc = "Write `a ^ (-1) mod n` in `res`."]
    #[doc = ""]
    #[doc = "The argument a and the outparam res are meant to be 4096-bit bignums, i.e. uint64_t[64]."]
    #[doc = "The argument k is a montgomery context obtained through Hacl_Bignum4096_mont_ctx_init."]
    #[doc = ""]
    #[doc = "Before calling this function, the caller will need to ensure that the following"]
    #[doc = "preconditions are observed."]
    #[doc = "• n is a prime"]
    #[doc = "• 0 < a"]
    #[doc = "• a < n"]
    pub fn Hacl_Bignum4096_mod_inv_prime_vartime_precomp(
        k: *mut Hacl_Bignum_MontArithmetic_bn_mont_ctx_u64,
        a: *mut u64,
        res: *mut u64,
    );
}
extern "C" {
    #[doc = "Load a bid-endian bignum from memory."]
    #[doc = ""]
    #[doc = "The argument b points to len bytes of valid memory."]
    #[doc = "The function returns a heap-allocated bignum of size sufficient to hold the"]
    #[doc = "result of loading b, or NULL if either the allocation failed, or the amount of"]
    #[doc = "required memory would exceed 4GB."]
    #[doc = ""]
    #[doc = "If the return value is non-null, clients must eventually call free(3) on it to"]
    #[doc = "avoid memory leaks."]
    pub fn Hacl_Bignum4096_new_bn_from_bytes_be(len: u32, b: *mut u8) -> *mut u64;
}
extern "C" {
    #[doc = "Load a little-endian bignum from memory."]
    #[doc = ""]
    #[doc = "The argument b points to len bytes of valid memory."]
    #[doc = "The function returns a heap-allocated bignum of size sufficient to hold the"]
    #[doc = "result of loading b, or NULL if either the allocation failed, or the amount of"]
    #[doc = "required memory would exceed 4GB."]
    #[doc = ""]
    #[doc = "If the return value is non-null, clients must eventually call free(3) on it to"]
    #[doc = "avoid memory leaks."]
    pub fn Hacl_Bignum4096_new_bn_from_bytes_le(len: u32, b: *mut u8) -> *mut u64;
}
extern "C" {
    #[doc = "Serialize a bignum into big-endian memory."]
    #[doc = ""]
    #[doc = "The argument b points to a 4096-bit bignum."]
    #[doc = "The outparam res points to 512 bytes of valid memory."]
    pub fn Hacl_Bignum4096_bn_to_bytes_be(b: *mut u64, res: *mut u8);
}
extern "C" {
    #[doc = "Serialize a bignum into little-endian memory."]
    #[doc = ""]
    #[doc = "The argument b points to a 4096-bit bignum."]
    #[doc = "The outparam res points to 512 bytes of valid memory."]
    pub fn Hacl_Bignum4096_bn_to_bytes_le(b: *mut u64, res: *mut u8);
}
extern "C" {
    #[doc = "Returns 2^64 - 1 if a < b, otherwise returns 0."]
    #[doc = ""]
    #[doc = "The arguments a and b are meant to be 4096-bit bignums, i.e. uint64_t[64]."]
    pub fn Hacl_Bignum4096_lt_mask(a: *mut u64, b: *mut u64) -> u64;
}
extern "C" {
    #[doc = "Returns 2^64 - 1 if a = b, otherwise returns 0."]
    #[doc = ""]
    #[doc = "The arguments a and b are meant to be 4096-bit bignums, i.e. uint64_t[64]."]
    pub fn Hacl_Bignum4096_eq_mask(a: *mut u64, b: *mut u64) -> u64;
}
